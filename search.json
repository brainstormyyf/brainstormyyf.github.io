[{"content":"一、I/O系统基本概念 外部设备 输入设备 鼠标、键盘 输出设备 显示器 种类 阴极射线管显示器（CRT） 电子枪、偏转线圈、荧光粉等组成 液晶显示器（LCD） 利用液晶分子的光电效应 发光二极管显示器（LED） 通过发光二极管发光来显示 参数 屏幕大小 以对角线长度表示 分辨率 屏幕上像素点的个数 灰度级 表示一个颜色需要多少二进制位数 刷新频率 单位时间内更新屏幕的次数 显示存储器（VRAM） 容量=分辨率*灰度级位数（2010） 带宽=容量*刷新频率（2010） 打印机 针式打印机 喷墨式打印机 激光式打印机 外部存储器 磁表面存储器 固态硬盘（SSD） 光盘存储器 二、I/O接口 1. I/O接口的功能 进行地址译码和设备选择、实现主机和外设的通信联络控制、实现数据缓冲、信号格式转换、传送控制命令和状态信息 2. I/O接口的基本结构 （状态端口和控制端口可以合用一个寄存器） 3. I/O接口的类型 并行接口/串行接口 程序查询接口/中断接口/DMA接口 可编程接口/不可编程接口 4. I/O端口及其编址 概念 接口电路中可被CPU直接访问的一组寄存器（2014） I/O指令实现的数据传输通常发生在通用寄存器和I/O端口之间（2017） 编址 统一编址（存储器映射） 使用统一的访存指令来完成输入输出操作（2014） 端口有较大的编址空间但内存容量变小 统一编址下的I/O地址可以在地址空间的任何地方 靠不同的地址码区分存储单元和I/O设备 独立编址（I/O映射） 使用专门的输入输出指令（IN/OUT） 靠不同的指令区分存储单元和I/O设备 三、I/O方式 1. 程序查询方式 工作流程 CPU向I/O接口发出命令字，启动I/O设备 CPU不断从接口读取状态信息，直到外设准备就绪 传输一次数据，修改地址和计数器参数 反复执行直到计数器为0 特点 一段时间内CPU只能和一个外设交换信息，CPU要花费大量时间查询和等待 2. 程序中断方式 中断原理 （CPU与外设并行工作示意图） 中断优先级 中断源的识别和判优 软件查询 原理 按照中断优先顺序依次查询哪个设备有中断请求并转到第一个查询到的中断服务程序去执行 特点 可以改变软件的查询顺序来改变中断响应优先级，比较灵活；但查询速度较慢 硬件判优 原理 根据中断判优电路和编码器得到所有未被屏蔽的中断请求中具有最高响应优先权的中断源 涉及到的概念 中断向量 中断服务程序的首地址 中断向量地址 每个中断向量所在的地址 中断向量表 所有中断向量存放在一个表中称为中断向量表 中断类型号 每个中断向量在中断向量表中的位置或编号 中断优先级 分类 中断响应优先级 由查询程序或判优电路决定的优先权（不可更改），反映的是多个中断同时请求时选择哪个先被相应 中断处理优先级 由各自的中断屏蔽字来动态设定（可以更改），反映了本中断与其它中断之间的处理优先关系（2020） 优先顺序 不可屏蔽中断\u0026gt;内部异常\u0026gt;可屏蔽中断（2020） 内部异常中，硬件故障\u0026gt;软件故障 DMA中断\u0026gt;I/O中断（2020） I/O中断中，高速设备\u0026gt;低速设备，输入设备\u0026gt;输出设备，实时设备\u0026gt;普通设备 中断屏蔽字 每个中断源都有屏蔽触发器，所有屏蔽触发器组合在一起构成中断屏蔽字寄存器，其中的内容称为屏蔽字 “1”表示屏蔽，“0”表示正常申请（每个中断源都要屏蔽自身）（2011） 例：A\u0026gt;B\u0026gt;C\u0026gt;D C的屏蔽字为0011 中断响应的三个条件 CPU处于“开中断”状态（2018、2021） 至少有一个未被屏蔽的中断请求（2021） 当前指令刚执行完（2018） 中断过程（经常考） 中断响应（硬件实现） 关中断 将中断允许标志置为不允许状态，此时可屏蔽掉所有可屏蔽中断请求 保存断点 将PC和PSW送入栈或特殊寄存器 识别中断源 取得中断服务程序首地址和初始 PSW分别送PC和PSWR 中断处理（软件实现） 保护现场（用户可见的工作寄存器的内容）和屏蔽字 开中断 执行中断服务程序 关中断\u0026mdash;-恢复现场和屏蔽字\u0026mdash;-开中断\u0026mdash;-中断返回 3. DMA方式 基本概念 全名：直接存储器存取。在外设与内存之间直接开设一条数据通道，由DMA控制器控制数据传输，数据不再经过CPU 适用于磁盘、显卡、声卡、网卡等高速设备大批量数据的传送（鼠标键盘适合中断方式） 数据流向：内存\u0026ndash;数据总线\u0026ndash;DMA控制器\u0026ndash;外设 DMA传送方式 CPU停止法 CPU脱离总线停止访问主存 周期挪用法 CPU让出一个总线事务周期，DMA控制器挪用一个主存周期来访问主存传输一个数据缓冲寄存器的内容（2020） 交替分时访问法 每个存储周期分为两个时间片，一个给CPU，一个给DMA控制器 DMA传送过程（经常考） 图示 步骤 预处理 CPU完成一些准备工作后执行原来程序，I/O设备准备好收发数据后向DMA控制器发出DMA请求信号，DMA控制器向CPU发出总线请求信号（申请总线使用权） 数据传输 DMA控制器占用总线后进行数据传输（此阶段完全由DMA控制器控制，CPU不可以访问主存储器）（2018、2020） 后处理 数据传输完成后DMA控制器向CPU发出中断请求并转入中断服务程序，做一些数据校验等后续处理工作（2020） 中断和DMA方式的比较 （经常涉及到） 四、考研大题 出题年份：2009、2012、2016、2018\n出题方向\n程序查询 查询的最大间隔 中断 给出主频、CPI、中断处理程序指令个数、数据传输速率、求CPU利用率 能否使用中断？否，因为CPU来不及处理，数据可能丢失 中断过程：设备把数据送给缓冲寄存器\u0026mdash;-I/O接口发出中断请求\u0026mdash;-CPU响应并执行中断处理程序 DMA 给出主频、CPI、中断处理程序指令个数、数据传输速率、求CPU利用率 DMA请求优先级高于CPU，原因是数据不及时传送可能丢失（2012大题） 补充（异步串行通信）\n","date":1708779471,"headings":[{"anchor":"1-io接口的功能","title":"1. I/O接口的功能"},{"anchor":"1-程序查询方式","title":"1. 程序查询方式"},{"anchor":"2-io接口的基本结构","title":"2. I/O接口的基本结构"},{"anchor":"2-程序中断方式","title":"2. 程序中断方式"},{"anchor":"3-dma方式","title":"3. DMA方式"},{"anchor":"3-io接口的类型","title":"3. I/O接口的类型"},{"anchor":"4-io端口及其编址","title":"4. I/O端口及其编址"},{"anchor":"一io系统基本概念","title":"一、I/O系统基本概念"},{"anchor":"三io方式","title":"三、I/O方式"},{"anchor":"二io接口","title":"二、I/O接口"},{"anchor":"四考研大题","title":"四、考研大题"},{"anchor":"外部设备","title":"外部设备"}],"kind":"page","lang":"zh-hans","summary":"","tags":["计算机组成原理"],"title":"第七章：输入输出系统","url":"/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/","year":"2024"},{"content":"六、总线概述 1. 总线的基本概念 同一时刻只允许有一个部件向总线发出信息 主设备是指获得总线控制权的设备；从设备是指被主设备访问的设备且只能被动响应各种总线命令 2. 总线的分类 片内总线 芯片内部的总线（寄存器之间、寄存器与ALU之间） 系统总线 数据总线 特点 双向传输 位数与机器字长、存储字长有关 传输内容 数据、中断向量、状态信息、命令字（2011、2012） 地址总线 特点 单向传输 位数与主存地址空间的大小有关 传输内容 要访问的地址 控制总线 特点 对于特定的一条控制总线传输是单向的 但对于所有控制总线来看，传输是双向的 传输内容 读写、请求、响应、时钟信号、复位信号 I/O总线 连接中低速的I/O设备并通过I/O接口与系统总线相连接，目的是将低速设备与高速总线相分离（USB、PCI） 通信总线 同步总线、异步总线 下面6.2的总线定时细讲 串行总线、并行总线 串行总线抗干扰能力强，适合远距离传输 并行总线抗干扰能力弱，但在近距离传输时速度很快 串行并不一定比并行慢，现在的发展趋势是并行传输速度\u0026laquo;串行传输速度（2016） 3. 系统总线的结构 单总线结构 双总线结构 主存总线+I/O总线 多总线结构 主存总线+I/O总线+DMA总线 4. 常见的总线标准 （PCI并行、PCI-E串行、USB串行）（真题中涉及到的：ISA、EISA、VESA、APG、USB、PCI-E） 5. 总线的性能指标 总线传输周期 一次总线操作所需要的时间（包括申请阶段、寻址阶段、传输阶段和结束阶段）（经常考） 总线工作频率 为总线传输周期的倒数（经常考）（现在有些总线一个时钟周期可以传输2次或4次数据） 总线时钟周期 也就是机器的时钟周期 总线时钟频率 为总线时钟周期的倒数 总线宽度 总线上同时能够传输的数据位数 总线带宽 可以理解为总线的最大数据传输率 总线带宽=数据传输速率=总线频率*总线宽度=单位时间内传输的二进制信息位数（经常考） 总线传送方式 非突发传输 每次先传输地址，再传输数据 突发传输 每次传输一次地址，再传输多个数据（2014） 可以提高同步总线数据传输率（2016、2018） 二、总线事务和定时 1. 总线事务 请求阶段-仲裁阶段-寻址阶段-传输阶段-释放阶段 2. 总线定时 同步式 由统一的时钟信号进行协调，而不能由各设备提供（2015） 提高同步总线带宽措施 提高时钟频率、增加数据线宽度、支持突发传输、拆分总线事务、不采用分时复用（2018） 优点 控制逻辑简单、传输速度较快 缺点 总线定时以最慢设备所花时间为标准，所以只适合连接速度相差不大的设备 由于时钟偏移问题总线的长度不能过长 异步式 没有统一的时钟，也没有固定的时间间隔，靠“握手信号”实现定时控制 特点：灵活、接口逻辑复杂、对噪声敏感、传输速度较慢 分类 不互锁（速率最快，最不可靠）（2015） 请求\u0026mdash;-撤销请求 半互锁（介于中间） 请求\u0026mdash;-回答\u0026mdash;-撤销请求 全互锁（速率最慢，最可靠）（2015） 请求\u0026mdash;-回答\u0026mdash;-撤销请求\u0026mdash;-撤销回答 图示 半同步 按照统一的时钟信号（同步特点），增加一条“等待”响应信号从而使不同速度的模块和谐工作（异步特点）（2015） 三、基于总线的互连结构（补充） 1. 图示 （总线之间需要通过桥接器相连接） 2. 总线细节 前端总线 速度最快的总线 QPI总线 基于包的串行传输总线，连接不同CPU内核 双向传输，每个时钟周期传输两次（2020） 带宽=每秒传输次数_每次传输的有效数据_2（2020） 存储器总线 注意多通道存储器，计算时带总带宽=单个通道宽*n（2019） I/O总线 第一代 XT、ISA、EISA、VESA（这些总线早已被淘汰，了解即可） 第二代 PCI、AGP、PCI-X 第三代 PCI-Express 采用串行传输方式（2017） PCI-Express*n表示有n个通路，每个通路有两个差分信号线可以同时发送和接收数据 在发送和接收时每个字节的数据被转换为10位信息被传输 总线带宽=每个方向接收或发送速率_2_通路数/10 ","date":1708779171,"headings":[{"anchor":"1-图示","title":"1. 图示"},{"anchor":"1-总线事务","title":"1. 总线事务"},{"anchor":"1-总线的基本概念","title":"1. 总线的基本概念"},{"anchor":"2-总线定时","title":"2. 总线定时"},{"anchor":"2-总线的分类","title":"2. 总线的分类"},{"anchor":"2-总线细节","title":"2. 总线细节"},{"anchor":"3-系统总线的结构","title":"3. 系统总线的结构"},{"anchor":"4-常见的总线标准","title":"4. 常见的总线标准"},{"anchor":"5-总线的性能指标","title":"5. 总线的性能指标"},{"anchor":"三基于总线的互连结构补充","title":"三、基于总线的互连结构（补充）"},{"anchor":"二总线事务和定时","title":"二、总线事务和定时"},{"anchor":"六总线概述","title":"六、总线概述"}],"kind":"page","lang":"zh-hans","summary":"","title":"第六章：系统总线","url":"/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/","year":"2024"},{"content":"一、CPU的功能和基本结构 1. CPU的功能 指令控制 操作控制 时间控制 数据加工 中断处理 2. CPU的基本结构 组成 运算器 算数逻辑单元 进行算术逻辑运算 暂存寄存器 用于暂存从主存读来的数据 累加寄存器 暂存ALU运算的结果，可以作为加法运算的一个输入端 通用寄存器组 存放操作数和各种地址信息（不存放指令） 程序状态字寄存器 保存各种运行过程中产生的状态信息 移位器 对操作数或者运算结果进行移位运算 计数器 控制乘除运算的操作步数 控制器 程序计数器PC 取指阶段（PC）\u0026ndash;\u0026gt;（MAR）后便能+1 执行转移指令时PC值不一定修改（条件不满足） 在执行无条件转移指令过程中，PC值改变两次 PC+1可以自己完成，也可以通过ALU完成 指令寄存器 保存当前正在执行的指令 指令译码器 对操作码字段进行译码并向控制器提供特定的操作信号 存储器地址寄存器 存放要访问的主存单元的地址 存储器数据寄存器 存放要写入主存或读出主存的信息 时序系统 用于产生各种信号，它们都由统一时钟（CLOCK）分频得到 微操作信号发生器 根据IR、PSW和时序信号产生各种控制信号 二、指令执行过程 1. 各种周期的关系 机器周期通常以存取周期为基准，存储字长等于指令字长时取指周期也可视为机器周期 CPU周期也就是机器周期，各个机器周期的长度不一定相等 2. 指令周期的数据流 取指周期 （PC）\u0026ndash;\u0026gt;MAR; M（MAR）\u0026ndash;\u0026gt;MDR; （MDR）\u0026ndash;\u0026gt;IR; （PC）+1\u0026ndash;\u0026gt;PC 间指周期 Ad（IR）\u0026ndash;\u0026gt;MAR; M（MAR）\u0026ndash;\u0026gt;MDR（不需要经过PC） 执行周期 数据在ALU运算的表示：（X）+（Y）\u0026ndash;\u0026gt;Z; （Z）\u0026ndash;\u0026gt;某个寄存器 中断周期 保存断点（（PC）\u0026ndash;\u0026gt;M（SP-1）），中断向量\u0026ndash;\u0026gt;PC （书写标准） 3. 指令执行方案 单周期CPU 所有指令采用相同的时钟周期完成，以花费时间最长的指令的时间为准，因此处理器时钟频率较低（2016） 每条指令执行过程中控制信号不变（2016） 同一个功能部件不能被重复使用（2016） 不能使用单总线结构数据通路（2016） CPI=1（2020） 指令串型执行，不需添加临时寄存器存放中间结果 （袁春风课本上的结构图，了解即可） 多周期CPU 可以选用不同个数的时钟周期来完成不同指令的执行过程 每条指令分成多个阶段 需要添加临时寄存器存放指令执行的中间结果 同一个部件可以在不同的阶段被重复使用 4. 大题 注意存储器控制信号（MemR、MemW）、算术逻辑单元控制信号（ALUop、add） 操作码+源操作数+目的操作数，目的操作数用来存放运算结果 ADD (R1),R2：R1寄存器间接寻址，R2寄存器直接寻址 书写指令功能时，一般为B\u0026lt;\u0026ndash;（A），即A的内容存放到B中 自增型寄存器间接寻址，意思是寻址完了后，把寄存器中的数值+1 加法器和ALU不是一个东西，2015年考察了MUX（多路选择器）和ALU输出端的三态门 三、数据通路的功能和基本结构 1. CPU组成（袁春风书补充） 数据通路 定义：指令执行过程中数据所经过的路径以及部件 包括：ALU、通用寄存器、状态寄存器、Cache、MMU、浮点运算逻辑、异常和中断处理逻辑（2017、2021） 元件分类 组合逻辑元件 定义：输出只取决于当前的输入 包括：多路选择器、加法器、算术逻辑部件、译码器等 （时序）状态元件 定义：具有存储功能 包括：暂存寄存器、通用寄存器组等 控制部件 主要是指令译码器 2. 数据通路的基本结构 CPU内单总线 图示 经常考 特点 一个时钟周期只能执行一个操作，一个时钟周期内控制信号不会发生改变（2016） 所有寄存器输入端、输出端都接到一条公共通路上 ALU一端与总线直接连接，另一端必须通过暂存器与总线连接 CPU内三多总线 几乎不会考，略过 专用数据通路 几乎不会考，略过 四、控制器的功能和工作原理 1. 硬布线 别名：组合逻辑电路、有限状态机。电路原理几乎不考，了解即可 CU的输入 指令译码、时钟信号、状态标志 2. 微程序 每个时钟执行一条微指令；每个指令周期执行一条微程序 微指令 微指令组成 微操作码字段：产生各种操作控制信号 微地址码字段：控制下一条要执行的微指令的地址 编码方式 直接编码 一位对应一个微命令，微操作码的长度与所有微命令的个数相当，无需译码 字段直接编码 微操作之间存在两种关系：相容（能同时进行）个互斥（不能同时进行） 将微指令分为若干字段，互斥的在同一段，相容的在不同段（2012） 每段还要留出一个状态表示不发出微命令（2012） 一条微指令中最多可同时发出的微操作数就是微命令字段的个数 间接编码 一个字段的微命令需要另一个字段的微命令解释（了解即可） 后继地址形成（按袁春风书） 计数器法 使用一个专门的微程序计数器uPC 顺序执行时，uPC+1\u0026ndash;\u0026gt;uPC；转移执行时在当前微指令后添加一条转移微指令 断定法 在微指令中明确指定下一条微指令地址（2014） 增加了微指令的长度，影响控制存储器的有效利用 微指令的格式 水平型 微指令长，微程序短、执行速度快、编写麻烦、一条指令对应几种并行操作 垂直型 微指令短、微程序长、执行速度慢、编写简单、一条指令对应一种基本操作 混合型 3. 硬布线和微程序的比较 （2009） 五、中断和中断机制（按袁春风书） 1. 中断（极其重要） 分类 内部异常 根据发生原因分 硬故障中断 电源掉电、存储器线路错误（硬件线路出现异常） 程序性异常 溢出、地址越界、整数除零、非法指令、时间片中断、单步跟踪（CPU执行某个指令引起） 根据异常的报告和返回方式 故障 非法操作码、缺段缺页、整数除零（不能回到原断点执行必须终止）、保护错 陷入 程序调试断点、系统调用（用户程序的I/O请求）、条件自陷指令（返回到自陷指令的下一条指令执行） 终止 电源掉电、线路故障等（程序无法执行只能终止，不是由特定指令引起而是随机发生的） 中断（外中断） I/O设备中断、定时器到时、时钟中断、打印机缺纸、键盘缓冲满（这些事件与执行的指令无关） 其它 内部异常的产生与当前指令的执行有关，而外部中断的产生与当前指令的执行无关 内部异常的检测发生在指令执行过程中，外部中断的检测发生在每条指令执行结束时 内部异常是由CPU发现和识别的，外部中断必须经过CPU对中断请求线采样并获取设备信息才能识别 缺页发生在CPU外（内存）但却是内部异常，且缺页中断结束后必须回到当前指令执行 Cache缺失不是内部异常也不是外部中断 不可屏蔽中断（全部内中断、突然掉电）；可屏蔽中断（外设请求） 2. 响应处理过程 中断响应 关中断 改变中断允许触发器 保存断点（PC和PSW） 识别中断源 取得中断服务程序首地址和初始 PSW分别送PC和PSWR 中断处理 保护现场（寄存器信息）和屏蔽字 开中断 执行中断服务程序 关中断\u0026mdash;-恢复现场和屏蔽字\u0026mdash;-开中断\u0026mdash;-中断返回 六、指令流水线 1. 流水线设计 设计原则 流水段个数以最复杂指令所用的功能段个数为准，流水段长度以最复杂的操作所花时间为准（2009、2018） 流水段有自己的寄存器，长度可能不同，存储的是下一阶段用到的控制信息和下面所有阶段的控制信息 指令集特征 指令长度尽量一致，格式尽量规整 使用Load/Store指令 数据和指令在存储器中对齐存放 2. 流水线的性能指标 功能段：一个指令执行过程分为几个功能段，理想情况下一个功能段需要一个时钟周期 吞吐率=处理指令数n/所用时间t 加速比=不使用流水线所用时间/使用流水线所用时间 效率=有效面积/总面积 3. 五段式指令流水线 图示 各阶段功能 取指令（IF） 从Cache或主存取指令 指令译码（ID） 产生指令执行所需要的控制信号 取操作数（OF） 读取存储器操作数或寄存器操作数 执行（EX） 对操作数完成制定操作 写回（WB） 将操作数写回存储器或寄存器 4. 高级流水线技术 超流水线技术 特点 增加流水线级数，配置多个功能部件，以空间换时间 图示 多发射流水线技术 静态多发射处理器（超长指令字） 特点 一条指令包含多个操作并行执行，能减少访存次数 图示 动态多发射处理器（超标量流水） 特点 CPU中有一条以上的流水线，每个时钟周期可以完成一条以上的指令，以空间换时间（2017） 能结合动态调度技术提高指令流水线的并行性（2017） 支持指令级并行，每个周期可以发射多条指令，由硬件完成指令调度 图示 5. 流水线的冒险与处理 结构冒险（资源冲突） 含义 同一个部件同时被不同指令使用（尤其是存储器、寄存器、ALU） 解决措施 指令存储器和数据存储器分开 规定功能部件在一条指令中只能使用一次 数据冒险（数据冲突） 含义 前面指令的结果是后面指令的操作数（2016、2019） 在正常执行的基本流水线中，所有数据冒险都属于写后读数据冒险 解决措施 软件NOP、气泡 数据旁路技术（转发技术）（2010） 编译优化，调整指令顺序 控制冒险（控制冲突） 含义 指令执行顺序改变（调用、转移、异常、中断）而引起流水线阻塞 解决措施 分支预测，尽早生成转移目标地址 预取转移成功和不成功两个控制流方向上的目标指令 提高转移方向的猜准率 加快和提前形成条件码 七、多处理器的基本概念 1. 基本分类 SISD（单指令流，单数据流） 平常学的计算机结构，可采用流水线CPU和交叉编址存储器 SIMD（单指令流，多数据流） 不同的处理单元执行同一条指令处理不同的数据，用在for循环、图像处理（数据级并行） MISD（多指令流，单数据流） 同时执行多条指令来处理同一个数据，实际中不存在 MIMD（多指令流，多数据流） 多处理器系统 多处理器一主存，可通过访存指令互相传送数据 多计算机系统 多处理器多主存，可通过消息传递互相传送数据 向量处理机 擅长向量运算和浮点计算 2. 硬件多线程 概念 目的：为了减小线程切换的开销 方法：为每个线程提供单独的通用寄存器朱、程序计数器等 分类 细粒度多线程 多个线程之间轮流交叉执行指令，每个时钟周期切换线程 粗粒度多线程 只在一个线程出现较大开销的阻塞才切换线程，切换开销较大 同时多线程 同一时钟周期发射多条指令执行，实现指令级并行和线程级并行 超线程技术 在一个CPU内提供两套线程处理单元，能够同时执行两个线程，但可能出现争抢资源的现象 超线程的性能要弱于两个CPU的性能 需要芯片组、操作系统和应用软件的支持 3. 多核处理器 将多个处理单元集成到单个CPU中，每个处理单元称为1个核 可以有自己的Cache也可以共享Cache,共享内存 若要发挥硬件性能，必须采用多线程或多进程技术 一般采用偶数路CPU 双核技术是指将两个CPU集成到一个封装，主板上有两个CPU属于多处理器 4. 共享内存多处理器（SMP） UMA（统一存储访问） 需要解决的重要问题是Cache一致性 每个处理器对所有存储单元的访问时间是大致相同的 NUMA（非统一存储访问） 访存请求快慢不同 相比之下运算扩展性更好 八、习题 通用寄存器可以存放指令和数据\n指令包括操作码和地址码，指令译码只对操作码解释\n取指周期取的是指令，间指周期取的是操作数的有效地址，而不是操作数\n取指操作是机器自动完成的，不需要指令控制\n微程序控制器的时序系统比较简单\n指令系统有n种机器指令，则微程序至少n+1个（公共取指微程序和中断微程序）\n取指操作是控制器固有的功能，不需要在操作码控制下完成\n指令周期一定大于等于一个时钟周期（2011）\n主存储器由RAM和ROM实现（2017）\n","date":1708778896,"headings":[{"anchor":"1-cpu的功能","title":"1. CPU的功能"},{"anchor":"1-cpu组成袁春风书补充","title":"1. CPU组成（袁春风书补充）"},{"anchor":"1-中断极其重要","title":"1. 中断（极其重要）"},{"anchor":"1-各种周期的关系","title":"1. 各种周期的关系"},{"anchor":"1-基本分类","title":"1. 基本分类"},{"anchor":"1-流水线设计","title":"1. 流水线设计"},{"anchor":"1-硬布线","title":"1. 硬布线"},{"anchor":"2-cpu的基本结构","title":"2. CPU的基本结构"},{"anchor":"2-响应处理过程","title":"2. 响应处理过程"},{"anchor":"2-微程序","title":"2. 微程序"},{"anchor":"2-指令周期的数据流","title":"2. 指令周期的数据流"},{"anchor":"2-数据通路的基本结构","title":"2. 数据通路的基本结构"},{"anchor":"2-流水线的性能指标","title":"2. 流水线的性能指标"},{"anchor":"2-硬件多线程","title":"2. 硬件多线程"},{"anchor":"3-五段式指令流水线","title":"3. 五段式指令流水线"},{"anchor":"3-多核处理器","title":"3. 多核处理器"},{"anchor":"3-指令执行方案","title":"3. 指令执行方案"},{"anchor":"3-硬布线和微程序的比较","title":"3. 硬布线和微程序的比较"},{"anchor":"4-共享内存多处理器smp","title":"4. 共享内存多处理器（SMP）"},{"anchor":"4-大题","title":"4. 大题"},{"anchor":"4-高级流水线技术","title":"4. 高级流水线技术"},{"anchor":"5-流水线的冒险与处理","title":"5. 流水线的冒险与处理"},{"anchor":"一cpu的功能和基本结构","title":"一、CPU的功能和基本结构"},{"anchor":"七多处理器的基本概念","title":"七、多处理器的基本概念"},{"anchor":"三数据通路的功能和基本结构","title":"三、数据通路的功能和基本结构"},{"anchor":"二指令执行过程","title":"二、指令执行过程"},{"anchor":"五中断和中断机制按袁春风书","title":"五、中断和中断机制（按袁春风书）"},{"anchor":"八习题","title":"八、习题"},{"anchor":"六指令流水线","title":"六、指令流水线"},{"anchor":"四控制器的功能和工作原理","title":"四、控制器的功能和工作原理"}],"kind":"page","lang":"zh-hans","summary":"","tags":["计算机组成原理"],"title":"第五章：中央处理器","url":"/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/","year":"2024"},{"content":"一、指令格式 1. 按操作数个数分类 零地址指令 不需要操作数的指令 空操作指令、停机指令、关中断指令 需要操作数的指令 两个操作数从栈顶和次栈顶弹出运算结构再压入堆栈 一地址指令 单操作数指令 加1、减1、求反、求补 双操作数指令 另一个操作数由ACC提供，运算结果放入ACC（(ACC)OP(A1)） 二地址指令 (A1)OP(A2)\u0026ndash;\u0026gt;A1 常用的算术逻辑运算指令 三地址指令 第三个地址用于存放运算结果 四地址指令 第四个地址用于存放下一条指令的地址 2. 定长操作码 指令格式固定 3. 扩展操作码 使用频率高的指令分配短操作码，使用频率低的指令分配长操作码 指令字长一般是存储字长的整数倍（2017） 4. 常见的汇编指令 二、指令寻址和数据寻址 1. 指令寻址 顺序寻址 PC=PC+1 跳跃寻址 跳跃只是改变PC的值，下条指令地址还是PC给出 由本条指令给出下条指令的地址 2. 数据寻址 基本概念 A：形式地址 EA：有效地址 （A）：地址内存储的内容 偏移寻址（2011） 基址寻址 为逻辑地址到物理地址的变换提供了支持，用以实现程序的动态重定位 基址寄存器的内容不变，形式地址不断改变（2019） 相对寻址 特别有利于程序浮动 PC存储的是下一条指令的地址，形式地址一般用整数补码表示（2009） 变址寻址 设定形式地址A为数组首地址，不断改变变址寄存器的内容 对线性表之类的数组元素进行方便的访问（2017、2018） 3. 考题 相对寻址相对的是PC+1；且要注意当前指令的长度 基址寻址的形式地址按无符号数存储，但计算时却按补码运算（2019） 大题给出了定长指令字的格式，就不能使用扩展指令字计算最值问题（2010、2015） 硬件：符号扩展器、移位寄存器、加法器、多路选择器（2013） 大题代码区：行号\u0026mdash;-虚拟地址\u0026mdash;-二进制机器指令\u0026mdash;-汇编代码 指令格式：操作码+源操作数+目的操作数（目的操作数存放运算结果）（2010） 三、程序的机器级代码表示 1. 无符号和带符号整数的大小比较（2011） 电路图 标志位 ZF：最终结果是否为0 OF：符号位进位情况异或最高数位进位情况 SF：符号位为多少 CF：Sub异或Cout（A+B大于表示范围或A-B的时A\u0026lt;B） 根据标志位分析结果 2. 常用汇编指令介绍 四、CISC/RISC的基本概念 （2009） 五、习题 为了缩短指令中某个地址段的位数，有效的方法是采取寄存器寻址\n简化地址结构的基本方法是采用隐地址\n在多道程序设计中，最重要的寻址方式是相对寻址\n","date":1708778299,"headings":[{"anchor":"1-指令寻址","title":"1. 指令寻址"},{"anchor":"1-按操作数个数分类","title":"1. 按操作数个数分类"},{"anchor":"1-无符号和带符号整数的大小比较2011","title":"1. 无符号和带符号整数的大小比较（2011）"},{"anchor":"2-定长操作码","title":"2. 定长操作码"},{"anchor":"2-常用汇编指令介绍","title":"2. 常用汇编指令介绍"},{"anchor":"2-数据寻址","title":"2. 数据寻址"},{"anchor":"2009","title":"（2009）"},{"anchor":"3-扩展操作码","title":"3. 扩展操作码"},{"anchor":"3-考题","title":"3. 考题"},{"anchor":"4-常见的汇编指令","title":"4. 常见的汇编指令"},{"anchor":"一指令格式","title":"一、指令格式"},{"anchor":"三程序的机器级代码表示","title":"三、程序的机器级代码表示"},{"anchor":"二指令寻址和数据寻址","title":"二、指令寻址和数据寻址"},{"anchor":"五习题","title":"五、习题"},{"anchor":"四ciscrisc的基本概念","title":"四、CISC/RISC的基本概念"}],"kind":"page","lang":"zh-hans","summary":"","tags":["计算机组成原理"],"title":"第四章：指令系统","url":"/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/","year":"2024"},{"content":"一、存储器概述 1. 存储器的分类 按存取方式 随机存取存储器 访问每个地址的时间都相同（RAM、ROM）（2011） 顺序存取存储器 信息顺序存放和读出（磁带） 直接存取存储器 兼有随机访问和顺序访问的特点（磁盘、光盘） 相联存储器 可以按照内容或地址寻找信息（快表） 按可保护性 断电后信息是否消失 （易失性）断电消失 RAM、cache （非易失性）断电不消失 ROM、光、磁存储器 读出后信息是否破坏 破坏性读 动态RAM 非破坏性读 静态RAM 按存储介质 磁表面存储器（磁盘、磁带）、半导体存储器（RAM、ROM）、光存储器（光盘） 按层次结构 主存 由RAM（用户程序）和ROM（系统程序）构成 TLB 采用相联存储器或SRAM（2018、2020） 高速缓存（Cache） 只能由SRAM构成 内存（主存） 辅存 磁盘、磁带、光盘等 2. 存储器的性能指标 存储容量 =存储字数*字长 单位成本 =总成本/总容量 存取速度 又名数据传输率、主存带宽 存取周期 根本定义：进行一次完整读写操作所需要的时间或者连续两次访存所需的最小时间间隔 （存取周期往往大于存取时间） 3. 多级层次的存储系统 （图示） 主存-Cache 由硬件完成，主要解决CPU和主存速度不匹配的问题 主存-辅存 由硬件和操作系统完成，主要解决存储系统容量的问题 二、主存储器 1. 随机存储器（RAM） 静态SRAM（Cache使用） 原理：由双稳态触发器（六晶体管MOS）组成 特点：存取速度快，集成度低、功耗大、价格昂贵 动态DRAM（主存使用） 原理：靠电容存储电荷的原理来寄存信息 集成度高、容量大、功耗低、地址复用（地址线为原来的1/2，分两次传输） 刷新 刷新方式 集中（利用一段连续时间，对所有行进行刷新） 优点：读写操作不受刷新工作的影响 缺点：存在死时间/死区（不能进行读/写操作） 分散（每个系统工作周期先读写操作后刷新一行） 优点：不存在死时间 缺点：增加了系统存取周期，降低了机器速度 异步（计算出刷新的时间间隔，每次刷新一行） 折中方案，既可以减少刷新次数，又可以缩短死时间 刷新特点 刷新是一行行进行的，一次刷新只需占用一个存取周期（2018） SDRAM 升级版的DRAM，也是电荷存储信息需要刷新，但是与CPU之间采用同步方式交换数据，支持猝发传输（2015） 2. 只读存储器（ROM） 掩膜ROM 出厂时直接写入，任何人无法修改 PROM（一次可编程） 用户可以编写一次，但之后不能修改 EPROM（可擦除可编程） 可编程多次，但编程次数有限且写入时间较长 改写方法 用紫外线照射，擦除时芯片中所有信息都会消失 EEPROM（电可擦除） 电可擦除，可以选择只删除个别字 FLASH（闪速存储器） 特点 属于ROM（存储元由MOS管组成），是半导体存储器，可随机存取（2012） 操作 编写 所有存储元最开始都是“1”，需要改为“0”的地方充电即可 擦除 对所有存储元都放电，使所有存储元都是“1” 读取 读速度比写速度快很多（2012） 固态硬盘SSD 2022年考纲新加，会细讲 3. 并行存储器结构技术（按袁春风书来） 双端口存储器 一个存储器有两个读写端口 若两个端口同时读写的地址不同，则正常读写互不影响 若两个端口同时读写相同的地址则发生冲突，按照特定的优先顺序进行读写 单体多字 一个存储体，每个存储单元存储m个字，一次读出m个字 缺点是指令和数据在主存内必须是连续存放的，否则效果就不明显 多模块存储器 连续编址方式\n（注意高位地址表示体号） 交叉编址方式\n（注意低位地址表示体号） 启动方式 轮流启动 （图示）（2015考） 两个重要公式 m\u0026gt;=T/r\nt=T+(m-1)r 同时启动（2017） 三、主存储器与CPU的连接 1. 主存容量扩展 字、位、字位扩展（经常考简单计算，扩展电路图从来不考） 扩展后形成的地址空间 扩展后编址默认是顺序编址（2010） 2. 片选法与线选法 线选法 高位地址信号直接连接各存储器的片选端 地址空间不连续，不能充分利用系统的地址空间 译码片选法 通常地址线低位作为位选，高位作为片选信号 （高位地址信号经过地址译码器后再连接到各存储器的片选端） 3. 芯片最小引脚数 SRAM 通常使用一维地址，地址线=2^n 总引脚=地址线+数据线+电源接地线+片选线1+读写线（1或2） 地址线通过芯片容量计算；数据线通过存储字长计算；电源接地线往往不考虑；片选线一定为1；读写线看题目描述 DRAM 通常使用二维地址，地址总线复用，引脚数减半 总引脚=地址线/2+数据线+电源接地线+行选通信号1+列选通信号1+读写线（1或2） 地址线通过芯片容量计算；数据线通过存储字长计算；电源接地线往往不考虑；行列选通信号和为2；读写线看题目描述（2014） 四、外部存储器 1. 磁盘存储器 磁盘设备的组成 （磁盘存储器由磁盘控制器、磁盘驱动器和盘片组成） 磁记录原理 磁头和磁性记录介质相对运动，通过电磁转换完成读写操作 磁盘存储器的一个最小读写单位为扇区（2019） 磁盘的性能指标 平均存取时间（2013、2015） 寻道时间 旋转延迟时间 转半周的时间 传输时间 按照读写速率和读写块的大小计算（2013） 按照磁盘旋转n个扇区的时间计算（2015） 记录密度 道密度 沿磁盘半径方向单位长度上的磁道数 位密度 磁道单位长度上能记录的二进制代码位数 面密度 =位密度*道密度 磁盘容量 格式化容量比非格式化容量小（2019）（操作系统会细讲原理） 数据传输率 根据具体情况计算 磁盘地址 驱动器号+柱面号+盘面号+扇区号（操作系统部分大题会考到） 硬盘的工作过程 读写操作是串行的，不能同时读写，也不能同时读两组数据或写两组数据 2. 磁盘阵列 RAID（独立冗余磁盘阵列） 由多个物理磁盘组成，数据交叉存储并行访问，有更好的存储性能、可靠性和安全性 总结（2013） 使用多个磁盘，提高了传输率 通过多个磁盘并行存取，提高了数据吞吐量 通过镜像功能，提高了安全可靠性 通过数据校验，提高了容错能力 3. 固态硬盘（SSD）（2022考纲新加，需注意） 基于闪存Flash，属于EEPROM 以页为单位读写，以块为单位擦除 读得快写得慢，但也比传统的机械硬盘快，且功耗低 缺点就是容易磨损，使用磨损均衡技术延长使用寿命 五、高速缓冲存储器 1. 程序访问的局部性（按袁书） 时间局部性 被访问的某个存储单元在较短时间内很有可能又被访问（通常由于程序的循环执行）（2017） 空间局部性 被访问的某个存储单元的邻近单元在较短时间内很有可能被访问（通常由于程序的顺序执行，如访问数组）（2017） 2. Cache的基本工作原理 通常由SRAM构成，Cache和主存划分为许多大小相同的快，每个块由若干字节组成 CPU访问地址命中Cache，则直接读Cache，若不命中则读主存同时把访问的字所在的主存块调入Cache 若Cache满了，则调入主存块时需要执行替换算法进行替换 CPU与Cache之间的交换以字为单位，Cache与主存之间的交换以块为单位 3. Cache和主存的映射方式 （三种映射方式示意图） 地址结构划分（做题基础） 首先根据题中映射方式确定地址结构 直接映射 地址：标记+Cache行号+块内地址 全相联映射 地址：标记+块内地址 组相联映射 地址：标记+Cache组号+块内地址 块内地址位数a 若为按字节编址，a=log2(主存块大小/字节长度) 若为按字编址，a=log2(主存块大小/字的长度) Cache行号位数b b=log2(Cache容量/主存块大小） Cache组号位数c c=log2（Cache容量/每组的大小） 标记位数d d=地址位数-前面计算过的各项长度（经常考） d=主存容量/Cache容量（不常用） Cache总容量的计算（2015、2021） （Cache总体结构示意图） 标记项长度计算 有效位 一定有有效位且长度为1位 脏位 采用回写法时长度为1位，否则长度为0 替换控制e 使用LRU替换算法时才会使用,一般在组相连映射中考察 e=log2（每组包含的Cache块数）【比如4路组相连时e=2，8路组相连时e=3】 标记位长度 上面已给出 Cache总容量=Cache块数*（每个Cache块标记项位数+数据位数） Cache命中率的计算 给出访存次数和访问Cache次数计算（2009） 组相联+LRU替换策略下计算Cache缺失次数（2012） 访问数组的Cache缺失率（2016）（修改数组一个单元的内容需要访问Cache两次即取出和存入） 4. Cache中主存快的替换算法 先进先出（FIFO） 选择最早调入的块进行替换 随机法 随机地选择块进行替换 近期最少使用（LRU） 符合程序访问的局部性原理 当集中访问的存储区超过cache组大小时，会出现颠簸抖动现象，命中率非常低 2^n路组相连，就需要n个LRU位（2018） 5. Cache写策略 写命中时 全写法 对cache写命中时，必须把数据同时写入cache和主存 回写法 对cache写命中只修改Cache内容，等此块被换出再写入主存 每个cache 需设置一个标志位，判断是否被CPU修改过（经常考） 写不命中时 写分配法 更新主存并更换cache块 非写分配法 更新主存不更换cache块 6. Cache结构示意图 （了解现代计算机往往采用多级Cache，且有时数据Cache和指令Cache相分离） 指令Cache和数据Cache相分离的主要目的是减少指令流水线的冲突（2014） 六、虚拟存储器 1.虚拟存储器的基本概念 主存和辅存共同构成了虚拟存储器，虚拟存储器具有主存的速度和辅存的容量 虚地址（逻辑地址） 用户编程允许涉及的地址 实地址（物理地址） 实际的主存单元地址 虚拟存储机制采用全相联映射和回写法 2. 分类 页式虚拟存储器 页表 作用是通过查表将虚页号转换为实页号 各页大小相等，虚拟地址结构为虚页号+页内地址 快表（TLB） 页表存放在主存中访问速度较慢，因此把部分页表内容放入快表中加快访问速度 TLB使用相联存储器 快表通常采用全相联或者组相联。全相联情况下TLB标记=虚页号；组相联情况下TLB标记+组号=虚页号 （TLB、page、Cache的访问情况组合）（2010） 段式虚拟存储器 段式按照程序的逻辑结构划分，各段长度因程序而异 段页式虚拟存储器 把程序按逻辑分段，每段再划分为固定大小的页 每个程序对应一个段表，每段对应一个页表 ","date":1708777881,"headings":[{"anchor":"1-主存容量扩展","title":"1. 主存容量扩展"},{"anchor":"1-存储器的分类","title":"1. 存储器的分类"},{"anchor":"1-磁盘存储器","title":"1. 磁盘存储器"},{"anchor":"1-程序访问的局部性按袁书","title":"1. 程序访问的局部性（按袁书）"},{"anchor":"1-随机存储器ram","title":"1. 随机存储器（RAM）"},{"anchor":"1虚拟存储器的基本概念","title":"1.虚拟存储器的基本概念"},{"anchor":"2-cache的基本工作原理","title":"2. Cache的基本工作原理"},{"anchor":"2-分类","title":"2. 分类"},{"anchor":"2-只读存储器rom","title":"2. 只读存储器（ROM）"},{"anchor":"2-存储器的性能指标","title":"2. 存储器的性能指标"},{"anchor":"2-片选法与线选法","title":"2. 片选法与线选法"},{"anchor":"2-磁盘阵列","title":"2. 磁盘阵列"},{"anchor":"3-cache和主存的映射方式","title":"3. Cache和主存的映射方式"},{"anchor":"3-固态硬盘ssd2022考纲新加需注意","title":"3. 固态硬盘（SSD）（2022考纲新加，需注意）"},{"anchor":"3-多级层次的存储系统","title":"3. 多级层次的存储系统"},{"anchor":"3-并行存储器结构技术按袁春风书来","title":"3. 并行存储器结构技术（按袁春风书来）"},{"anchor":"3-芯片最小引脚数","title":"3. 芯片最小引脚数"},{"anchor":"4-cache中主存快的替换算法","title":"4. Cache中主存快的替换算法"},{"anchor":"5-cache写策略","title":"5. Cache写策略"},{"anchor":"6-cache结构示意图","title":"6. Cache结构示意图"},{"anchor":"一存储器概述","title":"一、存储器概述"},{"anchor":"三主存储器与cpu的连接","title":"三、主存储器与CPU的连接"},{"anchor":"二主存储器","title":"二、主存储器"},{"anchor":"五高速缓冲存储器","title":"五、高速缓冲存储器"},{"anchor":"六虚拟存储器","title":"六、虚拟存储器"},{"anchor":"四外部存储器","title":"四、外部存储器"}],"kind":"page","lang":"zh-hans","summary":"","tags":["计算机组成原理"],"title":"第三章：存储器","url":"/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AD%98%E5%82%A8%E5%99%A8/","year":"2024"},{"content":"一、数制与编码 1. 进位计数制及其转换 （1）采用二进制编码的原因 二进制只有两种状态，使用物理器件制作成本低（2018） “1”与“0”正好与逻辑中的真假对应，方便实现逻辑运算（2018） 二进制的编码和运算简单，方便实现算术运算（2018） （2）不同进制间的相互转换 二进制转换为八进制\n从小数点开始向左向右每隔3位为一组 二进制转换为十六进制\n从小数点开始向左向右每隔4位为一组 十进制转换为二进制（不直接考但会间接用到）\n整数部分：除基取余法 小数部分：乘基取整法 （3）真值与机器数 真值\n用正负号表示的数值为真值，最真实的数值 机器数\n用“0”和“1”表示正负的数值为机器数，机器中使用的数 2. BCD码 2022版考纲删除此部分 3. 定点数的编码表示 机器数的定点表示\n表示法 定义 原码 最高位表示数的符号，其余位表示数值 补码 正数的补码是本身，负数的补码是符号位不变，其它各位取反后末位+1 反码 正数的反码是本身，负数的反码是符号位不变，其它各位取反 移码 只能表示整数，把补码的符号位取反便是移码，方便比较大小 请注意，移码通常用于浮点数的指数部分，以便于进行数值大小的比较。在移码表示法中，所有的非负数（包括零）的表示都是唯一的，并且数值越大，其移码表示也越大，这使得比较操作变得简单。 （假设字长n+1位） 4. 整数的表示 （1）无符号整数 无符号整数常用来表示内存地址 无符号数和带符号数相互转换，存储的数值不变，只是解释方式变了（2019） 表达式中存在无符号数和有符号数时，所有数都转换为无符号数类型（数值不变，解释方法变了） unsigned int 比 int所表示的正数的范围广，经常考察int溢出而unsigned int 不溢出的情况 四则运算 无符号数加法：X+Y=X+Y然后左边溢出的位数都扔掉 无符号数减法：X-Y=X+【-Y】补 乘除法：简单的移位运算，有些数据该丢掉就丢掉 无符号数-1=11111111 编程通常用a\u0026gt;b，而不用a-b\u0026gt;0（可能发生类型转换而出错） （2）带符号整数 计算机中的带符号整数都用补码表示 二、运算方法和运算电路 1. 运算电路 （1）标志寄存器 标志位名称 描述 溢出标志位（OF） 有符号数运算的结果发生溢出则为1（只针对有符号数）（2018） 进位标志位（CF） 无符号数运算向更高位进位或借位则为1（只针对无符号数）（2018） 零标志位（ZF） 执行结果为0则为1 符号标志位（SF） 执行结果为负则为1（只针对有符号数） 奇偶标志位（PF） 执行结果最低八位中1的个数为偶数个则为1 调整标志位（AF） 运算时最低半字节有进位或借位则为1 这些标志位是CPU状态寄存器的一部分，它们在执行算术和逻辑运算后由CPU自动设置，用于指示特定的运算结果状态，从而影响程序的执行流程，例如在条件分支指令中根据这些标志位的状态决定是否跳转。\n（2）算数逻辑单元 （3）加法器 ①一位全加器\n②串行加法器\n③并行加法器\n串行进位的并行加法器 并行进位的并行加法器 ④补码加减运算器 注意 无符号数加减法、补码加减法都可通过此电路实现 Sub信号加法为0，减法为1 CF=Sub异或Cout（2018） 2. 运算方法 （1）移位运算 算术移位（2018） 逻辑移位（2018）\n带上符号位一起移位（无论左移还是右移都补0） 循环移位\n分类 不带进位位CF 类似逻辑移位，CF不参与其中，但移位产生的副本会送进CF 带进位位CF 注意指向CF的箭头 （2）加减运算 溢出判断 一位符号位 符号位和最高数位，同时进位不进位或同时不进位不溢出，否则溢出（2010、2014、2018） 双符号位 特点 具有模2补码全部优点且更易检查加减运算中的溢出问题（不能解决溢出问题） 存储时只需要存一个符号位，只在ALU中运算时采用双符号位 结论 00：正数无溢出 11，负数无溢出 01，结果正溢出 10，结果负溢出 （3）乘除运算 乘法 乘法类型 描述 原码一位乘 累加次数n，右移次数n，符号位不参与运算 补码一位乘 累加次数n+1，右移次数n，符号位参与运算 在原码一位乘中，由于符号位不参与运算，所以需要额外的步骤来处理符号位，以确保结果的正确性。而在补码一位乘中，符号位的处理更加自然，因为它可以像其他位一样参与运算，这使得补码在计算机中的运算更加普遍。\n除法 运算方法 描述 原码加减交替法 加减次数n+1或n+2，左移次数n，符号位不参与运算 原码恢复余数法 补码加减交替法 加减次数n+1，左移次数n，符号位参与运算 乘除法从未考过电路原理或运算步骤 （4）类型转换 类型 描述 无符号数\u0026lt;\u0026ndash;\u0026gt;有符号数 数字不变，只不过解释方法变了（2012、2016、2019） 长\u0026ndash;\u0026gt;短 低位留着，高位截断 短\u0026ndash;\u0026gt;长 即符号扩展，数值不会发生变化 例子：\nchar(1B)\u0026ndash;\u0026gt;short(2B)\u0026ndash;\u0026gt;int(4B)\u0026ndash;\u0026gt;long(4B)\u0026ndash;\u0026gt;float(4B)\u0026ndash;\u0026gt;double(8B) 215=32768;216=65536（2012、2016默认记住） int\u0026ndash;\u0026gt;float可能影响精度（int数值在2^24范围内，float能精确表示，超过后可能不能精确表示） float\u0026ndash;\u0026gt;int可能影响精度（比如float含小数时转换过程中小数部分丢失），也可能会溢出（float表示范围远大于int） int\u0026ndash;\u0026gt;double一定不会出现精度丢失 undesignd（无符号数）：在运算时按照int型运算，在读取时按照无符号数 （5）符号扩展 正数 都是添0 负数 原码：添0 反码：添1 补码：整数添1；小数添0（2009） （6）数据存储和排列 ①基本概念\n对于一个数：10 23 45H LSB（最低有效字节）：45 MSB（最高有效字节）：10 ②存储方式\n大端方式：数据从高位到低位存储，即在一个多字节的数字中，最有效位（最高位）存储在最小的内存地址处。 小端方式：数据从低位到高位存储，即在一个多字节的数字中，最有效位（最高位）存储在最大的内存地址处。 大端小端方式考察频率非常高，一定要掌握！！ 存储方式 描述 大端方式 数据从高位到低位存储（符合习惯）（2020） 小端方式 数据从低位到高位存储（反人类法）（经常考） ③边界对齐方式（2012、2020）\n32位计算机按字编址，1字等于4B 字节随意存，半字地址是2整数倍，字地址是4整数倍，双字地址是8整数倍 三、浮点数表示与运算 1. 浮点数的表示 （1）浮点数的表示格式 （2）浮点数的表示范围\n正上溢和负上溢都是上溢，正下溢和负下溢都是下溢 尾数决定精度，阶码决定范围 （3）浮点数的规格化\n目的\n使尾数的有效数位尽可能多，从而提高运算的精度 途径\n左归（尾数左移）；右归（尾数右移） 表示法 规格化方式 基为2 原码规格化：0.1……/1.1……（尾数最高位一定是1） 补码规格化：0.1……/1.0……（尾数最高位和尾数符号位相反） 基为4、8 原码规格化：尾数最高两位或三位不全为0 阶码基为8，则表示的真值为8^(二进制阶码的真值） （4）IEEE754标准\n①图示\n经常考察把存储的二进制数转换为真值（2011、2014、2020） ②尾数M\n采用原码表示，且隐藏了最高位的1. ③阶码E\n采用移码表示，即减去127或者1023 短浮点数阶码的表示范围为-126~127 ④表示范围\n规格化浮点数 计算表示的最值（最大正负数、最小正负数等）（2012、2018）\n下面这个表格多次考察： 阶码 尾数 表示的值 全0 全0 0 全0 非全0（非规格化小数） 2^-126 * 0.xxxx（2018） 全1 全0 +∞（正无穷大）或 -∞（负无穷大） 全1 非全0（非数值） NaN（不是一个数，2012） 2. 浮点数的加减运算 （1）对阶\n小阶向大看阶齐，不会产生阶码溢出（2015） 右归时尾数右移，可能会舍掉有效位影响精度 （2）尾数求和 （3）规格化\n左归或右归 （4）舎入\n恒置1法 只要因移位而丢失的位中有1，就把尾数末位置1（原来是0或1，现在都置为1） 截断法 直接截取所需位数，丢弃后面所有位 0舍1入法 被舍去的最高数值位为0则直接舍去，被舍去的最高数值位为1则尾数的末位加1 这样做可能使尾数又溢出，此时还需要做一次右归（2015） （5）溢出判断\n溢出判断方法\n尾数的“溢出”不是溢出，规格化后，阶码的溢出才是真正的溢出（2015） 溢出处理方法\n上溢：绝对值太大，会引起溢出中断 下溢：绝对值太小，按0处理，一般不需要溢出中断 溢出类型 处理方法 上溢 绝对值太大，会引起溢出中断 下溢 当绝对值太小，按0处理，一般不需要溢出中断 四、习题 十六进制的数相加，直接按位相加，逢16进1即可 十进制转为八进制，可以先转为二进制再转为八进制 很多十进制小数都不能由二进制精确表示，如1.3 ALU属于组合逻辑电路 逻辑电路类型 描述 常见电路 组合逻辑电路 任意时刻的输出只与当前时刻的输入有关 多路选择器、编码器、译码器、比较器 时序逻辑电路 任意时刻的输出与当前时刻以及历史状态有关 锁存器、触发器 影响串行进位的并行加法器运算速度的关键因素是进位传递延迟 定点数运算不存在舎入，舎入不一定会产生误差 ","date":1708756687,"headings":[{"anchor":"1-浮点数的表示","title":"1. 浮点数的表示"},{"anchor":"1-运算电路","title":"1. 运算电路"},{"anchor":"1-进位计数制及其转换","title":"1. 进位计数制及其转换"},{"anchor":"1无符号整数","title":"（1）无符号整数"},{"anchor":"1标志寄存器","title":"（1）标志寄存器"},{"anchor":"1移位运算","title":"（1）移位运算"},{"anchor":"1采用二进制编码的原因","title":"（1）采用二进制编码的原因"},{"anchor":"2-bcd码","title":"2. BCD码"},{"anchor":"2-浮点数的加减运算","title":"2. 浮点数的加减运算"},{"anchor":"2-运算方法","title":"2. 运算方法"},{"anchor":"2不同进制间的相互转换","title":"（2）不同进制间的相互转换"},{"anchor":"2加减运算","title":"（2）加减运算"},{"anchor":"2带符号整数","title":"（2）带符号整数"},{"anchor":"2算数逻辑单元","title":"（2）算数逻辑单元"},{"anchor":"3-定点数的编码表示","title":"3. 定点数的编码表示"},{"anchor":"3乘除运算","title":"（3）乘除运算"},{"anchor":"3加法器","title":"（3）加法器"},{"anchor":"3真值与机器数","title":"（3）真值与机器数"},{"anchor":"4-整数的表示","title":"4. 整数的表示"},{"anchor":"4类型转换","title":"（4）类型转换"},{"anchor":"5符号扩展","title":"（5）符号扩展"},{"anchor":"6数据存储和排列","title":"（6）数据存储和排列"},{"anchor":"一数制与编码","title":"一、数制与编码"},{"anchor":"三浮点数表示与运算","title":"三、浮点数表示与运算"},{"anchor":"二运算方法和运算电路","title":"二、运算方法和运算电路"},{"anchor":"四习题","title":"四、习题"}],"kind":"page","lang":"zh-hans","summary":"","tags":["计算机组成原理"],"title":"第二章：数据表示与运算","url":"/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/","year":"2024"},{"content":"一、计算机发展历程 代数 主要元件 特点 第一代 电子管 占用空间大、耗电多、可靠性差、价格昂贵 第二代 晶体管 占用空间小、耗电少、可靠性高、价格相对较低 第三代 中小规模集成电路 进一步缩小体积、降低功耗、提高可靠性、增加计算速度 第四代 超大规模集成电路 集成度更高、计算速度更快、功耗更低、价格更加亲民 以上表格简要介绍了计算机的发展历程，从第一代到第四代，计算机的主要元件从电子管发展到超大规模集成电路，体积越来越小，计算速度越来越快，功耗越来越低，价格越来越亲民。\n二、计算机系统层次结构 1. 计算机系统组成 硬件系统和软件系统共同组成了一个计算机系统 2. 计算机硬件 （1）冯诺依曼计算机\n采用“存储程序”工作方式：程序事先存入主存，然后程序的指令按规定顺序执行 计算机由5部分组成：运算器、存储器、控制器、输入设备、输出设备- 指令和数据执行前都存放在内存中，CPU根据指令周期的不同阶段区分它们（2009） 指令和数据均用二进制代码表示（2019） 指令顺序存放，通常顺序执行（也可跳跃） 早期以运算器为中心，现代计算机以存储器为中心 （2）计算机的功能部件\n图示 ①输入设备\n键盘、鼠标、扫描仪、摄像机 ②输出设备\n显示器、打印机 ③存储器\n存储系统结构\n寄存器\u0026ndash;高速缓存（cache）\u0026ndash;主存\u0026ndash;外存（存取速度越来越慢） 工作方式\n按地址存取 绝大部分存储器都是如此 按内容存取 相联存储器 重要寄存器\nMAR（存储器地址寄存器）=地址码长度，能用于计算存储器的容量（2016） MDR（存储器数据寄存器）=存储字长 基本概念\n概念 定义 存储元件 最基本最小的元件，存储一位二进制0或1 存储单元 由若干个存储元件构成 存储字长 一个存储单元包含的二进制的位数 ④运算器\n功能 进行算术运算（加减乘除等）和逻辑运算（与或非、异或、比较、移位等） 组成 算术逻辑单元（ALU） 通用寄存器 累加器（ACC）、乘商寄存器（MQ）、操作数寄存器（X）、基址寄存器、变址寄存器 标志寄存器（PSW） ⑤控制器\n程序计数器（PC） 存放当前欲执行指令的地址，能自动“+1”从而指向下一条指令的地址 指令寄存器（IR） 存放当前执行的指令 控制单元（CU） 3. 计算机软件 （1）系统软件和应用软件\n类别 软件名称 系统软件 数据库管理系统、编译器、汇编程序、编译程序、连接程序 应用软件 数据库系统、文本编辑、驱动程序 （2）三个级别的语言\n语言类型 描述 机器语言 二进制代码，计算机唯一可以识别和执行的语言（2015） 汇编语言 用英文单词或缩写组成，便于人们理解记忆 高级语言 如C、C++、Java等。可以编译、汇编后得到机器语言程序，也可直接编译为机器语言程序 翻译程序类型 描述 编译程序 把高级语言源程序翻译为汇编语言或机器语言目标程序（2016） 一次全部，较快，能够生成目标程序 汇编程序 把汇编语言翻译成机器语言目标程序 解释程序 把源程序按执行次序逐条翻译成机器指令并立即执行 一次一句，较慢，不能生成目标程序 （3）软件和硬件在逻辑功能上是等价的\n4. 计算机工作过程 从源程序到可执行文件 阶段 描述 预处理 对以#开头的命令进行处理，如宏定义等，生成预处理后的源文件（.i） 编译 生成汇编语言源程序（.s） 汇编 把机器语言指令打包成为一个可重定位目标文件（.o） 链接 把多个可重定位目标文件和标准库函数合并成一个可执行目标文件（.o） 指令执行过程 取指令、分析指令、执行指令（后面章节会细讲） 5. 多级层次结构 高级语言机器\u0026ndash;汇编语言机器\u0026ndash;操作系统机器\u0026ndash;用机器语言的机器\u0026ndash;微指令系统 三、计算机的性能指标 1. 性能指标 （1）机器字长\n概念 定义 机器字长 CPU一次执行多少位数，等于ALU、内部寄存器的存储字长、通用寄存器长度、等于数据总线宽度（2020） 指令字长 指令的长度，指令字长为存储字长的整数倍且等于MAR长度 存储字长 一个存储单元的长度 （2）数据通路带宽\n数据总线一次所能并行传送信息的位数 （3）主存容量\n注意：1K=1024、1B=8bit、2^16=65536 （4）运算速度\n①吞吐量\n单位时间内处理请求的数量 ②响应时间\n用户发出请求到获得结果所需的时间 ③CPU时钟周期\n概念 定义 时钟周期 CPU中最小的时间单位，等于主频的倒数 机器周期（CPU周期） 完成一条指令中一个基本操作所需要的时间 指令周期 取出一条指令并执行完成的时间\n④主频\n机器内部主时钟的频率（2013、2014） ⑤CPI\n执行一条指令所需的平均时钟周期数（2013、2014） ⑥MIPS\n每秒执行多少百万条指令，等于主频/（CPI*10^6）（2013、2014） ⑦每秒浮点运算次数（xFLOPS）\nM（10^6）、G（10^9）、T（10^12）、P（10^15）、E（10^18）、Z（10^21）（2011、2021、2022） （5）基准程序\n在不同的机器上运行相同的基准程序，从而评测机器的性能（2012、2017） 2. 重要术语 术语 定义 系列机 体系结构与指令系统相同而型号不同的一系列计算机 兼容 软件或硬件的通用性 软件可移植性 把软件一直到同系列计算机上 固件 把程序固化在ROM中所组成的固件 四、习题 地址译码器 位于存储器中，能够通过输入的地址找到相应的存储单元 操作系统原语 原语是一段用机器指令编写的完成特定功能的程序,在执行过程中不允许中断。 寄存器由触发器构成\nxFLOPS是评估科学计算的计算机性能最有效的参数\n浮点寄存器\n不是CPU的一部分，而是浮点处理单元的一部分，决定计算机的计算精度 当前设计高性能计算机的重要途径是采用并行处理技术 透明 寄存器的透明性十分重要，经常考察。 在计算机体系结构中，\"不透明\"寄存器是指那些对程序员来说不可见或不可直接访问的寄存器，它们的操作由硬件或操作系统管理。而\"透明\"寄存器则是指那些程序员可以直接访问和操作的寄存器。有关寄存器的透明性可归纳如下： 类别 寄存器名称 不透明 PC（程序计数器） PSW（程序状态字寄存器） 通用寄存器组 基址寄存器（2020、2021） 透明 剩余的其他寄存器 ","date":1708753271,"headings":[{"anchor":"1-性能指标","title":"1. 性能指标"},{"anchor":"1-计算机系统组成","title":"1. 计算机系统组成"},{"anchor":"2-计算机硬件","title":"2. 计算机硬件"},{"anchor":"2-重要术语","title":"2. 重要术语"},{"anchor":"3-计算机软件","title":"3. 计算机软件"},{"anchor":"4-计算机工作过程","title":"4. 计算机工作过程"},{"anchor":"5-多级层次结构","title":"5. 多级层次结构"},{"anchor":"一计算机发展历程","title":"一、计算机发展历程"},{"anchor":"三计算机的性能指标","title":"三、计算机的性能指标"},{"anchor":"二计算机系统层次结构","title":"二、计算机系统层次结构"},{"anchor":"四习题","title":"四、习题"}],"kind":"page","lang":"zh-hans","summary":"","tags":["计算机组成原理"],"title":"第一章：计算机组成原理概论","url":"/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A6%82%E8%AE%BA/","year":"2024"},{"content":"一、I/O管理概述 1. I/O设备 （1）设备分类\n分类依据 设备类型 描述 示例 按信息交换单位 块设备 数据交换以块为单位，传输速率高，可寻址，采用DMA方式 磁盘 字符设备 数据交换以字符为单位，传输速率低，不可寻址，采用中断I/O方式 交互式终端机、打印机 按传输速率 低速设备 传输速率低，通常用于输入和输出 键盘、鼠标 中速设备 传输速率中等，常用于网络和存储设备 网卡、USB存储设备 高速设备 传输速率高，常用于高速存储和网络设备 SSD、千兆以太网卡 （2）I/O接口\n（组成：设备控制器与CPU的接口+设备控制器与设备的接口+I/O逻辑）\n（3）I/O端口\n概念：是指设备控制器中可被CPU直接访问的寄存器（数据、状态、控制寄存器） 编址方式：独立编制、统一编址 2. I/O控制方式 （1）程序直接控制方式、中断驱动方式、DMA方式（计组详细介绍）\n（2）通道控制方式\n通道：I/O通道是专门负责输入/输出的处理机，是DMA方式的发展 执行过程：CPU发送通道程序首地址和I/O设备\u0026ndash;\u0026gt;通道执行通道指令\u0026ndash;\u0026gt;传输结束向CPU发送中断请求 通道指令类型单一，通道程序存放在主机的内存中（通道与CPU共享内存） 通道与DMA 一个DMA控制一台设备与内存的数据交换；一个通道可以控制多台设备与内存的数据交换 DMA方式需要CPU控制传输的数据块大小、 传输的内存位置； 通道方式中这些信息都是由通道控制 DMA（直接内存访问）： DMA允许外部设备（如磁盘控制器、网卡等）在不经过CPU干预的情况下直接读写内存。当CPU启动一个DMA传输后，DMA控制器接管数据传输过程，根据预设的地址、传输方向和字节数进行数据交换。 在DMA方式下，虽然CPU不必参与每个数据字节的传输，但仍需要初始化DMA传输参数，如设置源地址、目的地址及传输长度等，并在传输完成后接收到中断通知。 每个设备通常需要自己的DMA控制器来管理其与内存之间的数据传输。 通道（Channels）： 通道是比DMA更高级别的I/O技术，常见于大型计算机系统中，它实际上是一个能够执行有限指令集的微型处理器，专门负责输入输出操作。 通道可以独立于CPU运行简单的程序（称为通道程序），这些程序能够管理和控制多个I/O设备的数据传输任务。 当CPU向通道发送一条I/O指令后，通道就能够自主完成一组相关的读写操作，包括设备寻址、数据缓冲区管理以及完成后的状态报告等，显著减少了CPU的介入次数。 一个通道可以连接并同时服务多个外设，实现真正的并行I/O操作，极大地提高了系统的并发处理能力。 注意DMA与通道的区别： 通道（Channels）和DMA（Direct Memory Access）都是为了提高I/O操作效率而设计的技术，DMA主要通过减少CPU在数据传输中的作用来提高效率，而通道则更进一步，不仅减少了CPU的干预，还提供了更强的并行性和自主性，使得I/O操作更为高效和灵活。 3. I/O软件层次结构 （1）用户层I/O软件\n实现与用户交互的接口， 用户可直接调用在用户层提供的、 与I/O操作有关的库函数 （2）设备独立性软件\n对用户提供统一接口，如read\\write命令 对设备的分配回收、逻辑设备名和物理设备名的映射、缓冲管理、差错控制、速率差异\u0026hellip; 把系统调用参数翻译成设备操作命令 （3）设备驱动程序\n与硬件直接相关，负责具体实现操作系统对设备发出的操作命令 把抽象I/O请求变为具体要求，如把read\\write命令变为设备能识别的命令 再例如将磁盘块号转换为磁盘的盘面、 磁道号及扇区号（2013） （4）中断处理程序\n进行进程上下文的切换，对处理中断信号源进行测试，读取设备状态和修改进程状态 是首先获得键盘输入信息的程序（2010） 4. 应用程序I/O接口 （1）字符设备接口、块设备接口、网络设备接口\n（2）I/O接口模式\nI/O操作类型 特点 阻塞I/O 用户进程调用I/O操作时， 进程就被阻塞， 需要等待I/O操作完成， 进程才被唤醒继续执行 非阻塞I/O 用户进程调用I/O操作时， 不阻塞该进程， 该I/O调用返回一个错误返回值 二、设备独立性软件 1. 高速缓存与缓冲区 （1）磁盘高速缓存\n目的：减少磁盘I/O次数（2015） 利用内存的存储空间来暂存从磁盘中读出的一系列盘块的信息 磁盘高速缓存逻辑上属于磁盘，物理上则是驻留在内存中的盘块 （2）缓冲区\n引入缓冲区的原因\n缓和CPU与I/O设备间速度不匹配的矛盾 减少对CPU的中断频率，放宽对CPU中断响应时间的限制 解决数据粒度不匹配的问题 提高CPU和I/O设备之间的并行性 （3）分类\n① 单缓冲区与双缓冲区 ② 环形缓冲区\n多个大小相等的缓冲区首尾相连构成一个环形 in指针指向可以输入数据的第一个空缓冲区 out指针指向可以提取数据的第一个满缓冲区 ③ 缓冲池\n了解即可 2. 设备分配与回收 （1）考虑因素\n固有属性 设备类型 描述 独占设备 使用时不再允许其他设备申请使用，属于临界资源，不合理分配可能会引起进程死锁（一般用静态分配） 共享设备 一段时间内被同时访问（而不是同一时间内被同时访问），分配不会引起进程死锁（一般用动态分配） 虚拟设备 虚拟设备：SPOOLing技术实现的，以空间换时间 安全性 安全分配：进程获得I/O后便进入阻塞状态 不安全分配：发出I/O请求后继续运行 （2）分配方式\n静态分配 作业开始前一次性分配完设备，不会死锁 动态分配 边运行边分配，可能死锁 （3）设备独立性\n概念：应用程序独立于具体使用的物理设备 I/O重定向：更换用于I/O操作的设备时不必更改应用程序（2020） 外部设备是一种特殊的文件，可以用文件名访问物理设备（2020） 为实现设备独立性，须在驱动程序上设置一层软件，称为设备独立性软件 程序员和应用程序使用逻辑设备名来请求某类设备（2009、2020） 系统实际执行时必须将逻辑设备名转为物理设备名（2020） 逻辑设备表LUT（逻辑设备名，物理设备名，驱动程序入口地址）用于实现逻辑设备名和物理设备名的转换 （4）设备分配中的数据结构\n设备控制表DCT（表述设备属性，如标识符、状态等） 控制器控制表COCT 通道控制表CHCT 系统设备表SDT（系统只有一张，包括设备类、设备标识符、DCT等） 逻辑设备表LUT（逻辑设备名，物理设备名，驱动程序入口地址） 分配的流程，从资源多的到资源紧张的:LUT-\u0026gt;SDT-\u0026gt;DCT-\u0026gt;COCT-\u0026gt;CHCT （5）分配步骤\n根据用户请求的I/O设备的逻辑名，查找逻辑设备和物理设备的映射表 以物理设备为索引，查找SDT，找到该设备所连接的DCT 根据DCT找到COCT再找到CHCT 在有通道的系统中，一个进程只有获得了通道，控制器和所需设备三者之后，才具备了进行I/O操作的物理条件 3. 假脱机系统（SPOOLing） （1）主要组成：\n（2）特点\n提高了I/O的速度和设备利用率 将独占设备改造为共享设备，以空间换时间 实际分给用户进程的不是打印设备，而是共享输出井中的磁盘上的一片存储区域 外设输入数据首先放在磁盘输入井中 由操作系统控制设备与输入/输出井之间的数据传送（2016） 在输入进程的控制下，＂输入缓冲区“用于暂存从输入设备输入的数据，之后再转存到输入井中 在输出进程的控制下，＂输出缓冲区“用于暂存从输出井送来的数据，之后再传到到输出设备上 （3）支持条件\n大容量高速度的外存、spooling相关软件、独占设备、多道程序设计技术（2016） 三、磁盘和固态硬盘 1. 磁盘结构 （1）图示\n（2）重要概念\n扇区：通常固定为512B，也称为盘块，是磁盘最小的物理存储单元 簇：由于扇区众多难以寻址，通常把2^n个扇区合并形成簇，一个簇中只能存放一个文件的内容（2017） （3）地址结构\n柱面号，盘面号，扇区号 假设每个磁道m个扇区，每个柱面n个盘面，每个盘面q个磁道。第x个盘块地址为 柱面号=x/mn；盘面号=（x%mn）/m；扇区号=x/m 2. 磁盘的管理 （1）磁盘初始化\n物理格式化 将磁盘各个磁道划分为扇区，一个扇区通常包含三部分 格式化后磁盘空间会减少，用来存储前导码、ECC校验码以及间隙 对磁盘分区 为什么要分区：方便管理、数据安全 逻辑格式化 建立文件系统 建立引导块、根目录、空闲块管理、空文件系统（2017） 为什么要逻辑格式化：操作系统无法识别系统上磁盘分区的格式 （2）坏块\n坏块标明 在FAT中指明，坏块对操作系统不透明 扇区备用 使用时用其它扇区替换，坏块对操作系统透明 3. 磁盘调度算法 （1）读写时间\n组成 寻找（寻道）时间、（旋转）延迟时间、传输时间 减少延迟方法 交替编号：让编号相邻的扇区在物理上不相邻 错位命名：让相邻盘面的扇区编号错位 （2）调度算法\n调度算法 描述 先来先服务（FCFS） 性能很差，但不会导致磁臂黏着（2018） 最短寻找时间优先 会导致饥饿现象 扫描算法（电梯算法、SCAN） 对各个未知的响应频率不均匀默认是LOOK算法（2015） 循环扫描算法（C-SCAN） 朝某方向移动到最末端后快速返回，返回期间不处理请求 LOOK/C-LOOK 不移动到最末端就可以返回\n4. 提高磁盘I/O速度途径 磁盘高速缓存：在内存中为磁盘盘块设置一个缓冲区，在缓冲区中保存了某些盘块的副本 提前读：在读当前块时也把下一个盘块数据读入缓冲区（2012） 延迟写：缓冲区的数据不立即写回磁盘，因为可能会在不久后被访问（2012） 重排I/O请求次序（2012） 优化文件物理块分布（2012） 虚拟盘：利用内存空间去仿真磁盘 廉价磁盘冗余阵列 方法：把数据分别存储到不同磁盘的相同位置，各个磁盘数据并行传输 优点：速度提高n-1倍；牺牲1/n的容量为代价 5. 固态硬盘 （1）图示\n基于闪存技术 （2）特性\n数据以页为单位读写，只有在一页所属的块被整个擦除后才能写这一页 ①随机写比随机读慢很多 ②比起传统机械硬盘读写速度更快、没有机械噪声和震动， 能耗更低、 抗震性好、 安全性高 （3）磨损均衡\n动态磨损均衡 写入数据时， 自动选择较新的闪存块。 老的闪存块先歇一歇 静态磨损均衡 没有数据写入时自动进行数据分配，让老闪存块承担无需写任务的存储任务，平时读写操作在新闪存块中进行 静态磨损均衡比动态磨损均衡的性能更好 ","date":1708597769,"headings":[{"anchor":"1-io设备","title":"1. I/O设备"},{"anchor":"1-磁盘结构","title":"1. 磁盘结构"},{"anchor":"1-高速缓存与缓冲区","title":"1. 高速缓存与缓冲区"},{"anchor":"2-io控制方式","title":"2. I/O控制方式"},{"anchor":"2-磁盘的管理","title":"2. 磁盘的管理"},{"anchor":"2-设备分配与回收","title":"2. 设备分配与回收"},{"anchor":"3-io软件层次结构","title":"3. I/O软件层次结构"},{"anchor":"3-假脱机系统spooling","title":"3. 假脱机系统（SPOOLing）"},{"anchor":"3-磁盘调度算法","title":"3. 磁盘调度算法"},{"anchor":"4-应用程序io接口","title":"4. 应用程序I/O接口"},{"anchor":"4-提高磁盘io速度途径","title":"4. 提高磁盘I/O速度途径"},{"anchor":"5-固态硬盘","title":"5. 固态硬盘"},{"anchor":"一io管理概述","title":"一、I/O管理概述"},{"anchor":"三磁盘和固态硬盘","title":"三、磁盘和固态硬盘"},{"anchor":"二设备独立性软件","title":"二、设备独立性软件"}],"kind":"page","lang":"zh-hans","summary":"","title":"第五章：输入输出系统","url":"/408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/","year":"2024"},{"content":"一、文件系统基础 1. 文件控制块和索引结点 （1）文件控制块\nFCB是用来存放控制文件需要的各种信息的数据结构（2009） FCB的有序集合称为文件目录，一个FCB就是一个文件目录项 （2）索引结点\n目录项结构：文件名+索引结点号（2020） 磁盘索引结点 每个文件对应有一个唯一的磁盘索引结点 内存索引结点 文件被打开时要将磁盘索引结点复制到内存索引结点便于以后使用 （3）图示\n2. 文件的操作 （1）文件的基本操作\n操作 描述 创建文件 create 分配一定的外存空间并创建一个目录项（参数：所需外存大小、文件存放路径、文件名） 读文件 read 参数：文件描述符fd、buf缓冲区首址、传送的字节数n（2012） 写文件 write 提供文件描述符、写回多少数据、写回外存的数据在内存什么位置 文件定位 搜索目录以找到适当的条目， 并将当前文件位置指针重新定位到给定值 删除文件 delete 释放外存空间并删除目录项（参数：文件存放路径、文件名）（2013）删除文件不必完成的操作是删除文件的快捷方式（2021） 截断文件 删除文件内容但文件所有属性不变 （2）文件的打开与关闭\n打开open：将文件属性从外存复制到内存打开文件表的一个表目中并将文件描述符fd返回给用户（2014） 此后对文件的读写操作不使用文件名而使用文件描述符，只有在操作文件时才把文件调入内存 关闭close：把进程打开文件表的相应表项删除，把系统打开文件表的打开计数器-1 两级表：\n关于进程的打开文件表和系统的打开文件的辨析十分重要,此处经常出题： ①不同的进程中会出现相同的文件描述符，它们可能指向同一个文件，也可能指向不同的文件 ②各进程的用户打开文件表中关于同一个文件F的读写指针位置一般不同（2017） ③各进程的用户打开文件表中关于同一个文件F的表项内容一般不同（2020） ④所有进程都关闭文件F时，系统打开文件表才会删除文件F对应的表项（2020） 3. 文件保护 （1）口令保护\n访问文件首先要输入口令，口令存在于FCB或索引结点中，不安全 （2）加密保护\n对文件进行加密，访问文件时需要密码对文件进行解密 （3）访问控制\n特点 对于一个文件的访问，常由用户访问权限和文件属性共同限制 访问控制列表（ACL）有三种用户类型：拥有者、组、其它 若用户和拥有者在同一组，则按照同组权限访问，否则只能按其它用户权限访问 图示 （2017） 4. 文件的逻辑结构 无结构文件（流式文件）：以字节为单位，如源程序文件、目标代码文件\n无结构文件考查较少，此处重点介绍有结构文件（记录式文件）：\n（1）顺序文件\n分类： 记录类型 结构 特点 变长记录 无法随机存取 定长记录 串结构 记录之间的顺序与关键字无关，无法快速存取 定长记录 顺序结构 记录顺序与关键字有关，可以快速存取 特点 优点：进行批量存取效率最高；缺点：修改、增加、删除记录比较困难 （2）索引文件\n组成 索引表 索引号+长度+指针（指向逻辑文件） 索引表是定长记录的顺序文件 特点 优点：增删方便，不定长记录也能随机存取；缺点：花费空间 （3）顺序索引文件\n流程 利用索引表找到记录所在的记录组的第一个记录 利用顺序查找法找到所需要的记录 特点 查找效率大大提高 （4）直接文件或散列文件\n给定记录的键值或通过散列函数转换的键值直接决定记录的物理地址，可能会产生地址冲突 5. 文件的物理结构 （1）连续分配\n每个文件占用一组连续的块，文件的目录条目包含（开始块、块数）（访磁盘1次） 优点：可以随机访问、访问很快（磁盘寻道时间短）（2013） 缺点：不利于文件扩展和删除，会产生磁盘碎片 （2）链接分配\n①隐式链接\n文件目录包括文件的首块指针和尾块指针，中间盘块之间相互链接对用户透明（访磁盘n次） 优点：不需要连续存放，不存在外部碎片 缺点：只能顺序访问，不能随机访问 ②显式链接\n把各指针显式存放在文件分配表（FAT） FAT表项：盘块号+下一块地址 FAT系统只有一张，开机后常驻内存 （3）索引分配\n为每个文件创建一个索引表（块）：逻辑块号+物理块号（访磁盘m+1次） 优点：可以随机访问，文件长度可变（2009、2020） 缺点：需要索引快，增加了系统存储空间的开销 （4）支持大文件机制\n链接方案 将多个索引快链接起来 多层索引 一级索引块指向二级索引块，二级索引块指向文件块 混合索引 二、目录 1. 目录结构 （1）单级文件目录\n文件不允许重名 （2）两级目录结构\n不同用户的文件可以重名 （3）树形文件目录\n绝对路径：从根目录出发的路径 相对路径：从当前目录出发的路径（加快文件索引速度）（2010） 2. 文件共享 （1）有向无循环图（硬链接）\n图示 特点 各个用户的目录项指向同一个索引结点 索引结点中有链接计数器count，只有count=0时才能删除 （2）符号链接（软链接）\n图示\n特点\n文件主才拥有指向索引结点的指针，其他文件只有该文件的路径名 当文件主删除文件后其它文件通过符号链接访问会失败，此时不会产生什么影响，可以把符号链接删除 优点：删除文件不会留下悬空指针；缺点：需要查询多级目录，时间长 建立符号链接时，引用计数值count直接复制（2009） 4.3文件系统 1. 文件系统布局 （1）图示\n（2）简单描述\n概念 描述 主引导记录 MBR 位于磁盘的0号扇区，确定活动分区并读入其中的引导块 分区表 给出每个分区的起始和结束地址 引导块 启动该分区中的操作系统 超级块 包含文件系统的所有关键信息（每个分区块的数量和块的大小、 空闲块的数量和指针、 空闲的FCB数量和FCB指针） 空闲空间管理 用位示图或指针链接的形式给出空闲块的信息 i结点区 存放i-node结点，每个文件对应一个i-node结点 根目录 存放文件系统目录树的根部 2. 外存空闲空间管理 （1）空闲表法\n（2）空闲链表法\n空闲空间管理方式 描述 空闲盘块链 所有空闲空间以盘块为单位拉成一条链 空闲盘区链 所有空闲盘区（每个盘区可包含若干个盘块） 拉成一条链 （3）位视图法\n用二进制的一位来表示磁盘中一个盘块的使用情况（0空闲1分配）（2015计算位视图具体位置） （4）成组链接法\nUNIX系统使用，适合大文件，把空闲扇区用指针链接起来 （5）文件分配表（2019）\n文件分配表（File Allocation Table，简称FAT）是计算机文件系统中的一个重要数据结构，它用于记录文件存储在存储设备（如硬盘、闪存盘等）上的位置。FAT系统最初是为MS-DOS操作系统设计的，后来被Windows操作系统所采用，尽管Windows后来推出了更先进的文件系统，如NTFS。\nFAT的工作原理如下：\n磁盘分区：磁盘被分成多个分区，每个分区可以包含一个文件分配表。 存储单元：磁盘被进一步划分为多个存储单元，这些单元通常称为“簇”（cluster）。每个簇可以包含一个或多个连续的扇区。 文件分配表：FAT本身是一个表格，其中包含了磁盘上每个簇的状态信息。每个表项对应一个簇，记录了以下信息： 该簇是否空闲。 如果簇已被文件使用，它是指向文件下一个簇的指针，或者是一些特殊值，如“结束簇”标记。 文件存储：当一个文件被保存时，文件系统会查找FAT中空闲的簇，并将这些簇的编号记录下来。如果文件超过一个簇，FAT会记录一个链，指示文件下一个簇的位置。 文件读取：当读取文件时，文件系统会根据FAT中的链来定位文件的数据簇，并按顺序读取这些簇，直到遇到结束簇标记。 FAT有几种不同的版本，如FAT12、FAT16、FAT32等，这些数字代表了FAT表项的大小，即它们可以引用的簇的数目。例如，FAT16每个表项可以引用2^16（65536）个簇，而FAT32每个表项可以引用2^32（4294967296）个簇。 随着磁盘容量的增加和文件大小的增长，FAT文件系统在处理大容量磁盘和大型文件时显得力不从心，因此出现了更先进的文件系统，如NTFS（New Technology File System），它提供了更好的性能、更大的容量支持和更强的可靠性。\n3. 虚拟文件系统 （1）概念\n概念：屏蔽了不同文件系统的差异和操作细节，向用户程序提供统一的调用函数 抽象了四种对象类型：超级块对象、索引结点对象、目录项对象、文件对象 并不是实际的文件系统且只存在于内存中，在系统启动时建立在系统关闭时消亡 （2）例子\n","date":1708589180,"headings":[{"anchor":"1-文件控制块和索引结点","title":"1. 文件控制块和索引结点"},{"anchor":"1-文件系统布局","title":"1. 文件系统布局"},{"anchor":"1-目录结构","title":"1. 目录结构"},{"anchor":"2-外存空闲空间管理","title":"2. 外存空闲空间管理"},{"anchor":"2-文件共享","title":"2. 文件共享"},{"anchor":"2-文件的操作","title":"2. 文件的操作"},{"anchor":"3-文件保护","title":"3. 文件保护"},{"anchor":"3-虚拟文件系统","title":"3. 虚拟文件系统"},{"anchor":"4-文件的逻辑结构","title":"4. 文件的逻辑结构"},{"anchor":"43文件系统","title":"4.3文件系统"},{"anchor":"5-文件的物理结构","title":"5. 文件的物理结构"},{"anchor":"一文件系统基础","title":"一、文件系统基础"},{"anchor":"二目录","title":"二、目录"}],"kind":"page","lang":"zh-hans","summary":"","title":"第四章：文件管理","url":"/408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/","year":"2024"},{"content":"一、论文总览 该论文提出了一种基于深度卷积神经网络（CNN）的图像分类方法，并在ILSVRC-2010和ILSVRC-2012图像分类挑战赛中取得了新的记录。主要工作和贡献如下：\n训练了当时最大的卷积神经网络，包含5个卷积层和3个全连接层，参数量达6000万个，在ILSVRC-2010测试集上取得了top-1错误率37.5%,top-5错误率17.0%,明显优于之前的方法。\n提出了几个新的网络架构优化技巧，如**ReLU激活函数、数据增强、局部响应归一化（Local Response Normalization）、重叠池化(Overlapping Pooling)**等，这些技巧显著提升了网络的性能。\n3. 模型并行（model parrallel）: 使用了两个GTX 580 3GB显卡并行训练，实现了高效的GPU卷积操作，显著减少了训练时间。\n使用了随机失活（dropout） 等正则化方法来控制过拟合，并详细分析了其有效性。\n在ILSVRC-2012比赛中使用该模型，取得了top-5错误率18.2%的成绩，显著优于第二名的16.4%。\n获得了大量视觉知识，如不同层级的卷积核表示，高维特征向量的相似度计算等。\n总体而言，该论文通过构建当时最大的卷积神经网络并使用各种优化技巧，在ImageNet等大规模图像数据集上取得了新的state-of-the-art结果，对后续的计算机视觉研究产生了重大影响。\n二、数据预处理/增强 使用的是ImageNet数据集，将所有图像缩放到256x256大小，如果图像尺寸不是正方形，先按比例缩小，然后从中间裁剪出256x256大小的正方形区域。\n注意：此处是直接使用的原始RGB图片，没有进行SIFT的特征提取，这也被看作端到端的训练模型，简化了训练以及推理的流程，这种端到端的思想深刻影响了深度学习模型的发展，目前大多数模型均是采用端到端的方法进行训练的。\n同时论文使用两种方法进行数据增强，第一种是对每张图片进行裁取和翻转，经过处理每张图片会得到十张图片输入模型预测出结果。第二种是对图片的RGB三个颜色通道进行平移和调整，即进行RGB通道强度调整。\n三、AlexNet网络结构分析 论文中的模型作者用了两块GPU进行训练，即使用了模型并行的方法，这种方法会给模型的工程实践带来困难，所以在之后随着显卡性能的提升已很少使用，但目前在NLP领域，LLM（large language model）的训练再次遇到了算力瓶颈，以GPT为代表的大模型再次使用模型并行的方法进行训练。\n模型一共有八层，前五层是CNN层，紧接着跟着两个全连接层，最后是一个1000类的softmax分类层。第二层，第四层，第五层的CNN层后面均跟着Max pooling层和LRM层（local response normalization，作用是防止过拟合）。两层全连接层均使用了Dropout的方法防止过拟合。实际上这两层全连接层是参数最多的，构成了模型训练的瓶颈，也是可能造成过拟合的罪魁祸首，为了防止过拟合，这两层全连接层都使用了Dropout的方法。\nLRM层现在基本已不再使用，其作用现在普遍认为也比较小，故本文不再做介绍，只需知道论文作者使用其本意是为了防止过拟合，提升模型泛化能力。\n其结构图可以简化为在单块gpu上进行训练的。\n图片来源：https://blog.csdn.net/guzhao9901/article/details/118552085?spm=1001.2014.3001.5506\n原图输入256 × 256，实际上进行了随机裁剪，实际大小为227 × 227。\n①卷积层C1\nC1的基本结构：卷积–\u0026gt;局部响应归一化(LRN)–\u0026gt;ReLU–\u0026gt;池化\n卷积：输入为227 × 227 × 3，使用96个11×11×3的卷积核，padding = 0，stride = 4。 FeatureMap为(227-11+0×2+4)/4 = 55，即55×55×96。 局部响应归一化(LRN)：对ReLU激活函数前的输出进行局部响应归一化处理。 激活函数：采用ReLU激活函数。 池化：3×3的池化核，padding = 0，stride = 2，池化后的FeatureMap为(55-3+0×2+2)/2=27, 即C1输出为27×27×96（若按照论文将数据分到两个GPU中处理，每组输出为27×27×48）。 ②卷积层C2\nC2的基本结构：卷积–\u0026gt;局部响应归一化(LRN)–\u0026gt;ReLU–\u0026gt;池化\n卷积：输入为27×27×96，使用256个5×5×96的卷积核，padding = 2， stride = 1。 FeatureMap为(27-5+2×2+1)/1 = 27，即27×27×256。 局部响应归一化(LRN)：在ReLU激活之前同样执行局部响应归一化操作。 激活函数：使用ReLU激活函数。 池化：3 × 3的池化核，padding = 0，stride = 2，池化后的FeatureMap为(27-3+0+2)/2=13, 即C2输出为13×13×256（若按论文方式分配到两个GPU，则每组输出为13×13×128）。 ③卷积层C3\nC3的基本结构为：卷积–\u0026gt;ReLU\n卷积：输入为13×13×256，使用384个3×3×256的卷积核，padding = 1，stride = 1。 FeatureMap为(13-3+1×2+1)/1 = 13，即13×13×384。 激活函数：采用ReLU激活函数，C3输出为13×13×384（若按照论文将数据分配到两个GPU中处理，则每组输出为13×13×192）。 ④ 卷积层C4\nC4的基本结构为：卷积–\u0026gt;ReLU\n卷积：输入为13×13×384，使用384个3×3×384的卷积核，padding = 1，stride = 1。 FeatureMap为13×13×384。 激活函数：采用ReLU激活函数，C4输出为13×13×384（若按论文方式分配到两个GPU，则每组输出为13×13×192）。 ⑤ 卷积层C5\nC5的基本结构为：卷积–\u0026gt;ReLU–\u0026gt;池化\n卷积：输入为13×13×384，使用256个3×3×384的卷积核，padding = 1，stride = 1。 FeatureMap大小仍为13×13×256。 激活函数：采用ReLU激活函数。 池化：池化核大小为3 × 3，padding = 0，stride = 2，池化后的FeatureMap为(13-3+0×2+2)/2=6, C5输出为6×6×256（若按照论文分到两个GPU中处理，每组输出为6×6×128）。 ⑥全连接层FC6\nFC6的基本结构为：卷积（全连接实现）–\u0026gt;ReLU–\u0026gt;Dropout\n全连接：实际上通过卷积进行等效的全连接操作，输入为6×6×256，使用4096个6×6×256的卷积核，padding = 0，stride = 1， FeatureMap大小为1×1×4096。 激活函数：采用ReLU激活函数。 Dropout：在全连接层中应用Dropout技术，随机丢弃一部分神经元节点，以防止过拟合，最终FC6输出为1×1×4096。 ⑦全连接层FC7\nFC7的基本结构为：全连接–\u0026gt;ReLU–\u0026gt;Dropout\n全连接：直接进行全连接操作，输入维度为1×1×4096。 激活函数：采用ReLU激活函数。 Dropout：同样应用Dropout防止过拟合，FC7输出为1×1×4096。 ⑧ 全连接层FC8\nFC8的基本结构为：全连接–\u0026gt;softmax\n全连接：对上一层的输出进行全连接操作，输入维度为1×1×4096。 softmax：最后采用softmax激活函数进行分类，输出维度为1×1×1000，对应1000类物体类别概率分布。 四、ReLU激活函数 $$ReLU(x)=max(0,x)$$\nReLU函数的导数：\n$$\\frac{dReLU(x)}{dx} = \\begin{cases} 1 \u0026amp; \\text{if } x \u0026gt; 0 \\ 0 \u0026amp; \\text{if } x \\leq 0 \\end{cases}$$ $${\\sigma(x)} = \\frac{1}{1 + e^{-x}}$$\nSigmoid函数的导数：\n$$\\frac{d\\sigma(x)}{dx} = \\sigma(x) * (1 - \\sigma(x)) = \\frac{e^{-x}}{(1 + e^{-x})^2}$$\n一个sigmoid函数大致相当于两个ReLU函数\n关于ReLU的具体分析可以见这篇文章：（暂未更新）\n五、重叠池化（overlapping pooling） 重叠池化(overlapping pooling)是一种改进传统的池化层的策略。传统的池化层通常由间隔一定距离的池化单元组成，每个单元对相邻的神经元输出进行汇总。相邻池化单元所覆盖的区域不重叠。而重叠池化则通过设置池化单元之间的间隔小于池化区域大小来实现重叠，例如使用间隔2像素的池化单元和区域大小为3x3的池化单元。文中提到，相比传统的非重叠池化，使用重叠池化可以将模型在ImageNet数据集上的top-1错误率降低0.4%，top-5错误率降低0.3%。因此，重叠池化是一种改进池化层设计的策略，能够提高模型性能。\n六、Dropout dropout是一种有效的正则化方法，可以减少深度卷积神经网络中全连接层过拟合的问题。\n注意：dropout是解决的全连接层过拟合的问题，所以论文中的两个全连接层使用了dropout，而CNN层没有使用dropout\ndropout的主要思想是：在每次前向传播时，以一定概率（如0.5）将每个隐藏神经元的输出置为0，使得每个神经元在每次前向传播时都有一定的概率不参与计算。论文中认为，这样做的目的是打破全连接层中不同神经元之间的复杂共适应性，迫使每个神经元学习更强大的特征表示，对不同的随机子集都有效。在测试时，不进行dropout，而是将每个神经元的输出乘以一定比例（如0.5），近似于取所有可能dropout网络结果的几何平均。\n现在普遍认为dropout相当于一个L2正则项，可以有效减少过拟合问题，同时让模型更强大。值得注意的是，dropout在训练时会增加迭代收敛次数，但可以大大提高模型的泛化能力。\n七、训练细节 使用随机梯度下降（SGD Stochastic Gradient Descent进行训练，批大小为128，动量为0.9，权重衰减为0.0005。发现权重衰减对模型学习非常重要。 对每个层的权重进行高斯初始化，均值为0，标准差为0.01。注意对权重进行均值为0标准差为0.01的高斯初始化现在非常常见，只有对一些特别深的网络例如GPT这样的模型，才会对权重做均值为0标准差为0.02的高斯初始化。 对第二、四、五卷积层以及全连接隐藏层的神经元偏置进行常数1初始化，其余层偏置初始化为常数0。（偏置常数1初始化理论性不强，多为实验炼丹结果，现在普遍将偏置初始化为常数0，结果也不差） 使用所有层相等的固定学习率，并在验证损失停止改善时手动将学习率变为原来的十分之一。初始学习率为0.01，训练过程中降低3次。 训练了大约90个周期，耗时5-6天在两块NVIDIA GTX 580 3GB GPU上进行训练。 损失函数是最小化交叉熵，即最大化标签的正确对数概率。 八、PyTorch代码实现 1import time 2import torch 3from torch import nn, optim 4import torchvision 5device = torch.device(\u0026#39;cuda\u0026#39; if torch.cuda.is_available() else \u0026#39;cpu\u0026#39;) 6 7class AlexNet(nn.Module): 8 def __init__(self): 9 super(AlexNet, self).__init__() 10 self.conv = nn.Sequential( 11 nn.Conv2d(1, 96, 11, 4), # in_channels, out_channels, kernel_size, stride, padding 12 nn.ReLU(), 13 nn.MaxPool2d(3, 2), # kernel_size, stride 14 # 减小卷积窗口，使用填充为2来使得输入与输出的高和宽一致，且增大输出通道数 15 nn.Conv2d(96, 256, 5, 1, 2), 16 nn.ReLU(), 17 nn.MaxPool2d(3, 2), 18 # 连续3个卷积层，且使用更小的卷积窗口。除了最后的卷积层外，进一步增大了输出通道数。 19 # 前两个卷积层后不使用池化层来减小输入的高和宽 20 nn.Conv2d(256, 384, 3, 1, 1), 21 nn.ReLU(), 22 nn.Conv2d(384, 384, 3, 1, 1), 23 nn.ReLU(), 24 nn.Conv2d(384, 256, 3, 1, 1), 25 nn.ReLU(), 26 nn.MaxPool2d(3, 2) 27 ) 28 # 这里全连接层的输出个数比LeNet中的大数倍。使用丢弃层来缓解过拟合 29 self.fc = nn.Sequential( 30 nn.Linear(256*5*5, 4096), 31 nn.ReLU(), 32 nn.Dropout(0.5), 33 nn.Linear(4096, 4096), 34 nn.ReLU(), 35 nn.Dropout(0.5), 36 # 输出层。由于这里使用Fashion-MNIST，所以用类别数为10，而非论文中的1000 37 nn.Linear(4096, 10), 38 ) 39 40 def forward(self, img): 41 feature = self.conv(img) 42 output = self.fc(feature.view(img.shape[0], -1)) 43 return output ","date":1708528866,"headings":[{"anchor":"一论文总览","title":"一、论文总览"},{"anchor":"七训练细节","title":"七、训练细节"},{"anchor":"三alexnet网络结构分析","title":"三、AlexNet网络结构分析"},{"anchor":"二数据预处理增强","title":"二、数据预处理/增强"},{"anchor":"五重叠池化overlapping-pooling","title":"五、重叠池化（overlapping pooling）"},{"anchor":"八pytorch代码实现","title":"八、PyTorch代码实现"},{"anchor":"六dropout","title":"六、Dropout"},{"anchor":"四relu激活函数","title":"四、ReLU激活函数"}],"kind":"page","lang":"zh-hans","series":["AI论文"],"summary":"","title":"AlexNet论文精读及模型详解","url":"/ai%E8%AE%BA%E6%96%87/alexnet%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB%E5%8F%8A%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/","year":"2024"},{"content":"一、进程与线程 1. 进程的概念和特征 （1）进程的概念\n进程是程序的一次执行过程（进程与程序的关系） 进程实体由程序段、相关数据段和PCB（进程控制块）构成 创建和删除进程的本质是创建和删除PCB PCB是进程存在的唯一标志 （2）进程的特征\n动态性 并发性 独立性 异步性 其中，动态性是进程最基本的特性\n2. 进程的状态与转换 进程状态 描述 创建状态 分配进程标识符并申请PCB\u0026mdash;-分配资源\u0026mdash;-初始化PCB\u0026mdash;-插入就绪队列 就绪状态 已分配到除CPU外的所有必要资源 执行状态 单CPU中同一时刻只能有一个进程在执行 阻塞状态 等待某一事件（通常是等待输入输出完成，比如等待打印机空闲） 终止状态 操作系统善后处理\u0026mdash;-PCB清零并返还系统 挂起操作 为了系统和用户观察分析进程。 在操作系统中，挂起原语（Suspend）和激活原语（Activate）与挂起状态（Suspended State）的关系是管理进程生命周期的一部分。\n挂起原语（Suspend）： 挂起原语是操作系统中用于将进程从运行状态或就绪状态转换到挂起状态的一个系统调用或操作。当一个进程被挂起时，它通常会释放所占用的资源，并且其状态会被设置为挂起状态。挂起状态意味着进程不会被操作系统调度执行，直到它被激活或者被终止。\n激活原语（Activate）： 激活原语与挂起原语相反，它用于将处于挂起状态的进程恢复到就绪状态。当进程被激活时，它的状态会被设置为就绪，这意味着它可以被操作系统调度执行，只要它满足执行条件（如没有更高的优先级进程正在执行）。\n挂起状态（Suspended State）： 挂起状态是进程可以进入的一种状态，当进程被挂起原语操作时，它就会进入这种状态。在挂起状态下，进程不会消耗CPU资源，也不会执行任何操作，直到它被激活。挂起状态通常用于暂停进程以便进行维护、调试或等待某些事件（如等待I/O操作完成）。\n总结来说，挂起原语和激活原语是操作系统用来控制进程状态转换的工具，而挂起状态则是进程在这些转换中可能经历的一种状态。通过这些操作，操作系统能够灵活地管理进程，以满足用户和系统的需求。\n3. 进程的组织 （1）进程控制块（PCB） （2）程序段\n能被进程调度到CPU执行的程序代码段（多个进程可以运行同一个程序） （3）数据段\n程序加工处理的原始数据或程序执行时产生的中间结果或最终结果 4. 进程控制 （1）进程的创建\n①父子进程 父子进程之间代码共享，数据独有 关系 一个进程创建另一个进程，创建者称为父进程，被创建者称为子进程 撤销子进程时，资源要归还父进程；撤销父进程时，要同时撤销所有子进程 子进程可以继承父进程所有资源 父子进程可以共享一部分资源，子进程创建也会分配自己独有的资源（2020） 父子进程不能共享虚拟地址空间（2020） ②引起进程创建的事件\n用户登录、作业调度、系统提供提供服务、应用请求、启动程序执行（设备分配不会引起进程创建）（2010） ③进程创建过程\n分配进程标识符并申请PCB\u0026ndash;\u0026gt;分配资源\u0026ndash;\u0026gt;初始化PCB\u0026ndash;\u0026gt;插入就绪队列（2021） （2）进程的终止\n引起进程终止的事件：\n正常结束：进程的任务已经完成并准备退出运行 异常结束：存储区越界、保护错、非法指令、特权指令错、运行超时、算术运算错、I/O故障等 外部干预：操作员或操作系统干预、父进程请求、父进程终止 （3）进程的阻塞和唤醒\nBLOCK原语是自我调用（自己阻塞自己），Wake up原语是被其它进程调用（其它进程唤醒） 5. 进程的通信 进程间的低级通信方式为PV操作，后面会细讲，这里先详细介绍一下高级通信方式\n（1）共享存储\n进程空间是独立的，一般不能被互相直接访问，所以需要一块共享空间作为中介 进程对共享空间的访问必须是互斥的 两个不同进程不能通过全局变量通信，全局变量是对同一进程而言的 分类 低级方式：基于共享数据结构 高级方式：基于共享存储区 （2）消息传递系统\n将数据封装在消息中，使用发送和接收原语在进程间传递消息从而完成数据交换 分类：\n通信方式 描述 直接通信方式 使用OS提供的发送原语直接将消息发送给目标进程 间接通信方式 通过共享中间实体（邮箱）,需要发送和接收原语 （3）管道通信系统 管道通信系统多次在选择题考察到，而且容易混淆，需要格外注意： ① 管道：连接一个读进程和写进程的共享文件，是一种独立的文件系统 ② 只存在于内存中，大小不受磁盘容量的影响（2014） ③ 管道满，写管道write()调用被阻塞；管道空，读管道read()调用被阻塞（2014） ④ 特点：同一时刻数据单向流动，半双工通信、必须写满或者读满（2014） ⑤ 一个管道的读进程只能有一个，写进程可以有多个（2014） 6. 线程和多线程模型 （1）线程的基本概念\n引入进程是为了多道程序并发执行；引入线程是未了减小程序切换的开销 线程组成：线程ID、程序计数器、寄存器集合、堆栈 同一进程中的线程切换不会引起进程切换；不同进程中的线程切换会引起进程切换 线程不拥有系统资源（仅有一点必不可少的资源） 同一进程的不同线程 线程共享资源：地址空间（拥有相同的地址空间）、全局变量、打开的文件、子进程（2012） 线程独享资源：程序计数器、寄存器、栈、状态字（2011） （2）线程与进程的比较\n进程是资源分配的基本单位；线程是处理机调度的基本单位 （3）线程的状态与转换\n执行态、就绪态、阻塞态（类比线程） （4）线程的实现方式\n①用户级线程\n有关线程管理（创建、撤销和切换等）的所有工作都在用户空间完成 内核意识不到线程的存在，处理及调度仍以进程为单位 内核每次分配给一个进程一个CPU，因此进程中仅有一个线程能执行 可以在不支持线程的操作系统上实现（2019） ②内核级线程\n有关线程管理的所有工作都在内核空间实现（2019） 处理机调度以线程为单位 内核能同时调度统一进程中的多个线程并行执行 内核级线程比用户级线程的切换效率低（2019） ③组合方式\n（5）多线程模型\n模型 描述 多对一模型 一个进程的多个用户级线程映射到一个内核级线程上。一个线程访问内核时阻塞则整个进程都被阻塞；任何时候只有一个线程能够访问内核 一对一模型 每个用户级线程都有一个内核级线程与之对应。一个线程被阻塞后，允许另一个线程运行，但开销较大 多对多模型 用户级线程与内核级线程之间存在多对多的映射关系。开销不大且并发性较高 二、处理机调度 1. 调度的概念 2. 调度的目标 性能指标 描述 CPU利用率 CPU在单位时间内用于处理作业的比率 系统吞吐量 单位时间内CPU完成作业的数量 周转时间 作业完成时间 - 作业提交时间 平均周转时间 n个作业的周转时间平均值 带权周转时间 作业周转时间/作业运行时间 平均带权周转时间 n个带权周转时间的平均值 等待时间 进程处于等待处理机的时间 响应时间 用户提交请求到系统首次产生响应所需要的时间 3. 调度的实现 （1）调度时机\n不能进行进程调度与切换的情况\n情况 描述 处理中断时 中断处理复杂很难同时进行进程切换 进程在操作系统内核临界区中 2012年真题指出进程在临界区时可以调度 其它需要完全屏蔽中断的原子操作中 加锁、解锁、中断现场保护、恢复 （2）进程调度方式\n非抢占调度（非剥夺） 不能用于分时系统和大多数实时系统 抢占式调度（剥夺） （3）闲逛进程\n进程切换时若没有其它进程就绪就执行闲逛进程 闲逛进程的优先级最低，只要有进程就绪就会立即让出处理机 闲逛进程不需要CPU之外的资源，因此不会被阻塞 4. 典型的调度算法 （1）先来先服务（FCFS）调度算法\n对长作业有利；对短作业不利 有利于CPU繁忙型作业（一般是长作业）；不利于I/O繁忙型作业（一般是短作业） （2）短作业优先（SJF）调度算法\n对长作业不利；对短作业有利 分为抢占式短作业优先和非抢占式式短作业优先（都会造成饥饿现象）（2011、2014） 平均等待时间、平均周转时间最少 （3）优先级调度算法\n调度相关特性 描述 是否可以抢占 剥夺式、非剥夺式 优先级是否改变 静态优先级、动态优先级 进程优先级设置原则 系统进程\u0026gt;用户进程；交互式进程\u0026gt;非交互式进程；I/O型进程\u0026gt;计算型进程（2013） （4）高响应比优先调度算法\n综合考虑了每个进程的等待时间和执行时间（2009） （5）时间片轮转调度算法\n主要适用于分时系统 时钟中断发生后，系统会修改当前进程在时间片内的剩余时间（2017） 时间片太大将退化为先来先服务调度算法；时间片太小处理机频繁进行进程切换则开销增大（2017） （6）多级反馈队列调度算法（2019、2020）\n步骤 设置多个队列，并为每个序列设置不同的优先级 优先级越高的队列中时间片就越小，每个队列都采用FCFS算法 进程进入内存后，先放入第1级队列的队尾，若未执行完，放入下一队列末尾 只有当前面的队列执行完，才能执行后面的队列 若有更高优先级的队列进入，当前进程放置所处队列的队尾，执行新来的进程 特点 对很多作业都能较好处理；可能造成饥饿 不会产生饥饿的调度算法：先来先服务、高响应比、时间片轮转。会产生饥饿：短作业优先、多级反馈队列（2011、2014） 5. 进程切换 （1）基本概念\n上下文：某一时刻CPU寄存器和程序计数器的内容 上下文切换：CPU从一个进程切换到另一个进程保存当前进程状态并回复另一个进程状态的过程 进程切换要在内核支持下完成 （2）上下文切换流程\n挂起一个进程，保存其CPU上下文，更新其PCB并移入相应的队列 选择新的进程，更新其PCB并转到程序计数器所指位置执行，恢复该进程的CPU上下文 （3）区分\n操作系统概念 解释 模式切换 用户态和内核态之间的切换 调度 决定资源分配给哪一个进程（一般现有资源调度后有进程切换） 上下文切换 CPU从一个进程切换到另一个进程，保存当前进程的状态，并恢复另一个进程的状态的过程 三、同步与互斥 1. 同步与互斥的基本概念 （1）基本概念\n概念 解释 临界资源 一次只允许一个进程使用的共享资源（打印机、共享变量、共享缓冲区、公用队列） 临界区 每个进程中访问临界资源的代码段 临界资源访问过程 进入区\u0026ndash;\u0026gt;临界区\u0026ndash;\u0026gt;退出区\u0026ndash;\u0026gt;剩余区 （2）直接相互制约（同步）\n进程为完成同一项任务而协调工作次序所产生的制约关系 （3）间接相互制约（互斥）\n对临界资源只能互斥地访问 互斥机制应遵循的规则：\n规则 描述 空闲让进 临界区空闲时，允许进程进入 忙则等待 已有进程进入临界区时，其他进程必须等待 有限等待 请求进入临界区的进程应在有限时间内进入 让权等待 当进程不能进入临界区时，应立即释放处理器（不是必须遵守的规则） 2. 实现临界区互斥的基本方法 （1）软件实现\n（2）硬件实现\n中断屏蔽方法: 进程在执行临界区代码时，通过关中断防止其它进程进入临界区\n3. 互斥锁 进程在进入临界区时获得锁，在退出临界区时释放锁 函数acquire()获得锁，函数release()释放锁，两者执行必须是原子操作。因此互斥锁通常采用硬件机制实现 主要缺点：忙等待 4. 信号量 （1）特点\n是低级进程通信，因为效率低、对用户不透明 PV操作是原子操作不可被中断；PV操作不是系统调用 V操作能让进程进入就绪状态；P操作能让进程进入阻塞状态 value为正表示还有同类资源；value为-m表示有m个进程处于阻塞态等待使用资源（2010） P（S）和wait（S）等价；V（S）和signal（S）等价（2022） （2）分类\n信号量类型 描述 整型信号量 wait(S): while(S\u0026lt;=0); S=S-1（这里可能卡在while语句一直循环占用处理器，故不遵循让权等待） 记录型信号量 增加一个进程链表指针list，用于链接所有等待该信号量的进程。在wait操作后，进程会添加到链表中等待，实现了让权等待。（2018） （3）应用\n同步/互斥类型 描述 进程同步 使用信号量实现，确保X在Y之前执行。初值S为资源数量。 S=0; X；V;P；Y 进程互斥 使用信号量实现，确保同一时刻只有一个进程能够进入临界区。 S=1; P1（P;临界区；V）；P2（P；临界区；V） 实现前驱关系 进程同步中S初值为资源数量，进程互斥中S初值必须为1 5. 管程机制 （1）组成\n管程的名称 局部于管程内部的共享数据结构说明 对该数据结构进行操作的一组过程（或函数） 对局部于管程内部的共享数据设置初始值的语句 （2）特点\n由编译语言支持的进程同步机制（2016） 管程可以用于实现进程的同步或互斥（2016） 所有进程都只能用过管程访问临界资源，管程每次只允许一个进程进入（2016） （3）条件变量\n一种抽象数据类型，保存一个链表，用于记录因该条件变量而阻塞的所有进程 x.wait：把进程挂在x对应的阻塞队列上；x.signal：唤醒x的阻塞队列上的一个进程（2018） 若没有等待进程，x.signal不会有任何操作，这与信号量中的signal不同（会修改信号量变量的值） 6. 经典同步问题 大题部分细讲 四、死锁 1. 死锁的定义 两个或两个以上进程因竞争资源而相互等待，若无外力作用这些进程都无法向前推进（2019）\n2. 死锁产生的原因 （1）系统资源的竞争\n竞争不可抢占性资源（磁带、打印机） （2）进程推进顺序非法\n问题描述 描述 竞争可消耗资源 信号量引起死锁 进程推进顺序不当 1. 请求和释放资源的顺序不当（A申请B占有的资源，B申请A占有的资源）2. 信号量使用不当（A等待B发消息，B等待A发消息） 3. 产生死锁的必要条件 产生死锁的四个必要条件必须牢固掌握！！！ 死锁条件 描述 互斥条件 进程对资源只能互斥访问（一段时间内只能有一个进程访问） 不可抢占条件 进程所获得的资源在未使用完毕前不可被其他进程剥夺。 请求和保持条件 进程保持了至少一个资源的同时请求其他资源。 循环等待条件 形成循环等待链，每个进程已获得的资源同时被下一个进程所请求。 4. 死锁的处理策略 （1）预防死锁\n死锁条件 破坏策略 破坏互斥条件 将临界资源改为可共享资源（SPOOLing技术） 破坏不可抢占 进程提出资源请求不能得到满足时释放自己已保持的全部资源 破坏请求和保持 进程在开始之前，必须一次性申请所需全部资源进程运行过程中逐步释放自己用过的资源再请求新资源 破坏循环等待 对系统所有资源线性排序，进程必须按顺序请求资源\n（2）避免死锁\n原理\n在资源动态分配过程中，防止系统进入不安全状态 银行家算法\n可以求出安全队列；需要知道进程所需全部资源数 银行家算法只能避免死锁，不能检测死锁（2013、2019） n个进程，每个进程所需设备为x1,x2\u0026hellip;xn，则保证不发生死锁的最小设备数为(x1-1)+(x2-1)+\u0026hellip;(xn-1)+1（经常考） 不安全状态与死锁\n死锁一定是不安全状态；不安全状态不一定是死锁（2013） （3）检测死锁\n资源分配图（有向图） （学会简化资源分配图） 死锁定理：S为死锁状态的充分条件是：当且仅当S的资源分配图是不可完全简化的 （4）解除死锁\n方法 描述 资源剥夺法 抢占某些死锁进程的资源分配给其它死锁进程（2019） 撤销进程法 撤销部分或全部死锁进程并剥夺这些进程的资源 进程回退法 让进程逐个回退到足以回避死锁的地步 ","date":1708509852,"headings":[{"anchor":"1-同步与互斥的基本概念","title":"1. 同步与互斥的基本概念"},{"anchor":"1-死锁的定义","title":"1. 死锁的定义"},{"anchor":"1-调度的概念","title":"1. 调度的概念"},{"anchor":"1-进程的概念和特征","title":"1. 进程的概念和特征"},{"anchor":"2-实现临界区互斥的基本方法","title":"2. 实现临界区互斥的基本方法"},{"anchor":"2-死锁产生的原因","title":"2. 死锁产生的原因"},{"anchor":"2-调度的目标","title":"2. 调度的目标"},{"anchor":"2-进程的状态与转换","title":"2. 进程的状态与转换"},{"anchor":"3-互斥锁","title":"3. 互斥锁"},{"anchor":"3-产生死锁的必要条件","title":"3. 产生死锁的必要条件"},{"anchor":"3-调度的实现","title":"3. 调度的实现"},{"anchor":"3-进程的组织","title":"3. 进程的组织"},{"anchor":"4-信号量","title":"4. 信号量"},{"anchor":"4-典型的调度算法","title":"4. 典型的调度算法"},{"anchor":"4-死锁的处理策略","title":"4. 死锁的处理策略"},{"anchor":"4-进程控制","title":"4. 进程控制"},{"anchor":"5-管程机制","title":"5. 管程机制"},{"anchor":"5-进程切换","title":"5. 进程切换"},{"anchor":"5-进程的通信","title":"5. 进程的通信"},{"anchor":"6-线程和多线程模型","title":"6. 线程和多线程模型"},{"anchor":"6-经典同步问题","title":"6. 经典同步问题"},{"anchor":"一进程与线程","title":"一、进程与线程"},{"anchor":"三同步与互斥","title":"三、同步与互斥"},{"anchor":"二处理机调度","title":"二、处理机调度"},{"anchor":"四死锁","title":"四、死锁"}],"kind":"page","lang":"zh-hans","summary":"","tags":["操作系统"],"title":"第二章：进程的描述与控制","url":"/408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/","year":"2024"},{"content":"一、内存管理概念 1. 基本原理和要求 （1）程序执行过程 ①编译\n编译形成若干目标模块，形成汇编文本 ②链接\n把一组目标模块和需要的库函数链接在一起形成一个装入模块 形成整个程序完整逻辑地址空间（2011） 分类： 链接方式 描述 静态链接方式 在程序运行之前把目标模块和库函数链接成一个完整的装配模块 装入时动态链接 边装入边链接 运行时动态链接 程序执行时需要该模块时才链接 ③装入\n把程序装入内存，且逻辑地址变为物理地址 分类： 装入方式 描述 特点 绝对装入方式 编译时便产生绝对地址，只适合单道程序环境 编译时确定内存位置，运行时无需改变地址 静态重定位 装入时对地址“重定位”，将逻辑地址一次性变为物理地址 作业装入内存时，必须分配其要求的全部内存空间；作业装入内存后不能再移动，只适合固定分区 动态重定位 装入内存后仍为逻辑地址，到程序真正执行时才地址转换，需要重定位寄存器的支持 程序只需装入部分代码就可运行；需要硬件支持（动态重定位寄存器） （2）进程的内存映像 （3）内存保护 基本概念 分区分配内存管理方式的主要保护措施是界地址保护（2009） 内存保护需要由操作系统和硬件机构合作完成 保护方法 设置上下限寄存器，每当CPU访问地址时进行比较判断是否越界 重定位寄存器和界地址寄存器配合 首先逻辑地址和界地址寄存器（含逻辑地址最大值）进行比较，判断是否越界 然后逻辑地址+重定位寄存器（含物理地址最小值）=物理地址 （4）内存共享 可重入代码（纯代码）：允许多个进程同时访问但不允许任何进程修改 2. 连续分配 分配策略 描述 特点 首次适应 空闲分区按地址递增顺序链接。 会留下很多碎片，但通常最快最好 循环首次适应 空闲分区按地址递增顺序链接 从上次找到的空闲分区的下一个空闲分区查找 最佳适应 空闲分区按容量递增顺序链接 最容易产生内存碎片（2019） 最坏适应 空闲分区按容量递减顺序链接 产生碎片的可能最小、会很快导致没有可用的大内存块 动态可重定位分区分配 紧凑：移动内存中作业位置，把分散的小分区拼接成大分区 3. 离散分配 （1） 分页 ①地址结构：页号+页内偏移量\n②分页存储基本概念\n用户程序分为“页”或“页面”，内存空间分为“物理块”、“页框”或“页帧”；它们都大小相同 地址结构：页号+页内地址 页面过大会使页内碎片增多；页面过小会使页表过大占用内存 页表 系统为每个进程建立一张页表，记录页号和物理块号的对应关系 页表由页表项组成，大多驻留在内存中 ③基本地址变换机构\n在系统中有一个页表寄存器（PTR），存放页表在内存的起始物理地址和页表长度（2021） 进程未执行时页表信息存放在进程PCB中，调度到进程时才把信息装入页表寄存器 ④快表\n也叫相联存储器（TLB），在地址变换机构中增设的，为了减少对内存的访问次数（经常考） ⑤两级页表\n目的：解决页表大而连续问题 页表级别 特点 单级页表 会产生很多页表，这些页表需要连续存储且进程执行时必须全部调入内存 二级页表 二级页表在进程执行时只需调入一级页表并调入所需页表 两级页表的地址结构：页目录号+页号+页内偏移量（经常考） 特点 顶级页表最多只能占一个页面 多级页表不能减少页表所占用的内存空间，但是能减少占用的连续内存空间（2014） 多级页表会减慢地址变换速度，可能增加缺页中断次数 （2）分段 ①地址结构：段号+段内偏移量（2009、2016）\n②特点\n呈现二维特性：既包含地址空间，又标识逻辑关系 各段可以不等长、可以不相邻 优点：方便编程；信息共享；信息保护；动态链接、动态增长等 ③分页和分段的区别\n概念 区别 页 信息的物理单位，大小固定，一维的。为了系统，对用户不可见。 段 信息的逻辑单位，大小不定，二维的。为了满足用户的需求。 （3） 段页式 地址结构：段号+段内页号+页内地址 一个进程中只有一个段表，每个段对应一个页表 段表寄存器和页表寄存器都有两个作用：在段表或页表中寻址、判断是否越界 二、虚拟内存管理 1. 虚拟内存基本概念 （1）传统存储方式特征 一次性：作业必须一次性全部装入内存后才能开始运行 驻留性：作业从开始运行到结束一直在内存中不会被换出 （2）局部性原理 局部性概念 描述 时间局部性 某条指令执行后不久可能再次执行，某个数据访问后不久可能被再次访问（程序的循环执行） 空间局部性 某个存储单元访问后不久其附近的存储单元会被访问（指令的顺序执行、数据以向量、数组、表等形式簇聚存储） （3）虚拟内存的特征 特征 描述 多次性 作业无需一次性全部装入内存，可以在需要时分多次调入内存。 对换性 程序和数据无需常驻内存，可以在内存和外存之间进行交换。 虚拟性 用户看到的逻辑内存容量远远大于实际的物理内存容量。 （4）虚拟内存技术的实现 必须建立在离散分配（分页分段）的内存管理方式基础之上（2012） 三种实现方式：请求分页、请求分段、请求段页式 虚拟内存的实际容量=min{内存+外存，地址位数表示能力}（2012） 虚拟内存的最大容量=地址位数的表示能力 2. 请求分页管理 （1）页表机制\n页表项： 页表项字段 描述 状态位 该页是否在内存（程序访问时参考） 访问字段 访问字段：页面访问次数（页面置换算法使用） 修改位 页面调入内存后是否被修改（页面置换时是否写回外存） 外存地址 页面对应的物理块号（地址转换使用） （2）缺页中断机构\n缺页中断属于内部异常，一条指令在执行期间可能产生多次缺页中断 3. 页框分配 （1）内存分配策略 ①固定分配局部置换\n固定分配：每个进程固定数目的物理块； 局部置换:只能在该进程所分配的内存页面进行调换 ②可变分配全局置换\n可变分配：每个进程的物理块可适当增加或减少； 全局置换：发现缺页将OS保留的空闲物理块取出一块分配 ③可变分配局部置换\n正常情况下是固定分配局部置换 若频繁缺页或缺页率一直很低，就采用可变分配全局置换 ④固定分配全局置换\n不存在（2015） （2）调入策略 ①何时调入\n调页策略 描述 预调页策略 一次调入若干个相邻的页，但页面可能不会被访问（主要用于进程的首次调入，由程序员指定） 请求调页策略 当发现页面不在内存时再调入，页面一定会被访问（所学的虚拟存储器就是采用这种方法） ②从何处调入\n外存划分 描述 I/O速度特点 文件区 用于存放文件，通常采用连续分配方式。 I/O速度较慢，因为涉及大量数据的读写。 对换区 用于存放对换页面，通常采用离散分配方式。 I/O速度较快，因为每次只访问少量数据。 情况 调入方法 若对换区足够大 都从对换区调入 若对换区不够大 不会修改的从文件区调入；可能被修改的换出时调到对换区，以后从对换区调入 UNIX方式 未运行过的页面从文件区调入；运行过但又被调出页面从对换区调入 ③如何调入\n当进程所访问的页面不在内存中时（存在位为0)，便向CPU发出缺页中断，中断响应后便转入缺页中断处理程序。该程序通过查找页表得到该页的物理块，此时如果内存未满，则启动磁盘IO，将所缺页调入内存，并修改页表。如果内存已满，则先按某种置换算法从内存中选出一页准备换出;如果该页未被修改过（修改位为0)，则无须将该页写回磁盘;但是，如果该页已被修改(修改位为1)，则必须将该页写回磁盘，然后将所缺页调入内存，并修改页表中的相应表项，置其存在位为1。调入完成后，进程就可利用修改后的页表形成所要访问数据的内存地址。（2011） 4. 页面置换算法 （1）最佳（OPT）置换算法 置换出未来最长时间不被访问的页面（不可实现） （2）先进先出（FIFO）置换算法 设第一个队列，总是淘汰最先进入内存的页面 可能出现Belady异常，即分配的物理块增多，缺页次数不减反增（2014） （3）最近最久未使用（LRU）置换算法 置换出最近最久未使用的页面 需要一组寄存器或一个栈的支持 （4） Clock置换算法 ①简单型\n某页被访问，置1；没有被访问，为0 算法步骤：置换算法检查到0，换出，检查到1，置0，这样循环进行 ②改进型\n再考虑一个因素：置换代价（修改过的页面置换代价大），将所有页面分为四类（访问位，修改位） 算法步骤 第一轮：寻找00的页面置换，不更改访问位和修改位 第二轮：寻找01的页面置换，同时将扫描过得页面的访问位置0 重复第一轮、第二轮\u0026hellip;\u0026hellip; 改进型Clock置换算法的页面置换顺序：00--01--10--11 5. 抖动和工作集 （1）抖动（颠簸）\n概念：刚刚换出的页面马上又要换入主存，刚刚换入的页面马上又要换出主存 产生原因：系统中运行的进程太多，内存分配给每个进程的物理块太少 抖动的预防策略 采用局部置换策略 使用工作集算法 利用“L=S”调节缺页率 L：缺页之间平均时间；S：置换一个页面所需时间 暂停一部分进程（增大对换区容量没有用）（2011） （2）工作集\n概念 解释 工作集 某段时间内进程访问的页面集合 工作窗口 这段时间的长度 驻留集 进程分配的物理页框的集合 工作窗口一般要远大于工作集；驻留集一般大于工作集 6. 内存映射文件 概念 将磁盘块映射到内存块，从而把进程对磁盘块的访问转换为对内存页的访问 作用 多个进程允许并发地内存映射同一个文件，以便实现数据共 很多时候共享内存是通过内存映射实现的，进程可以通过共享内存来通信 ","date":1708509852,"headings":[{"anchor":"1-分页","title":"（1） 分页"},{"anchor":"1-基本原理和要求","title":"1. 基本原理和要求"},{"anchor":"1-虚拟内存基本概念","title":"1. 虚拟内存基本概念"},{"anchor":"1传统存储方式特征","title":"（1）传统存储方式特征"},{"anchor":"1内存分配策略","title":"（1）内存分配策略"},{"anchor":"1最佳opt置换算法","title":"（1）最佳（OPT）置换算法"},{"anchor":"1程序执行过程","title":"（1）程序执行过程"},{"anchor":"2-请求分页管理","title":"2. 请求分页管理"},{"anchor":"2-连续分配","title":"2. 连续分配"},{"anchor":"2先进先出fifo置换算法","title":"（2）先进先出（FIFO）置换算法"},{"anchor":"2分段","title":"（2）分段"},{"anchor":"2局部性原理","title":"（2）局部性原理"},{"anchor":"2调入策略","title":"（2）调入策略"},{"anchor":"2进程的内存映像","title":"（2）进程的内存映像"},{"anchor":"3-段页式","title":"（3） 段页式"},{"anchor":"3-离散分配","title":"3. 离散分配"},{"anchor":"3-页框分配","title":"3. 页框分配"},{"anchor":"3内存保护","title":"（3）内存保护"},{"anchor":"3最近最久未使用lru置换算法","title":"（3）最近最久未使用（LRU）置换算法"},{"anchor":"3虚拟内存的特征","title":"（3）虚拟内存的特征"},{"anchor":"4-clock置换算法","title":"（4） Clock置换算法"},{"anchor":"4-页面置换算法","title":"4. 页面置换算法"},{"anchor":"4内存共享","title":"（4）内存共享"},{"anchor":"4虚拟内存技术的实现","title":"（4）虚拟内存技术的实现"},{"anchor":"5-抖动和工作集","title":"5. 抖动和工作集"},{"anchor":"6-内存映射文件","title":"6. 内存映射文件"},{"anchor":"一内存管理概念","title":"一、内存管理概念"},{"anchor":"二虚拟内存管理","title":"二、虚拟内存管理"}],"kind":"page","lang":"zh-hans","summary":"","tags":["操作系统"],"title":"第三章：内存管理","url":"/408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","year":"2024"},{"content":"一、仓库初始化和克隆 初始化新仓库： 1git init 该命令会在当前目录下创建一个名为.git的隐藏文件夹，用于存储Git仓库的相关信息。\n可在当前目录下创建一个.gitignore文件，用于指定 Git 应该忽略的文件和文件模式。这个文件非常有用，因为它可以帮助你隐藏不想提交到仓库的文件，比如编译生成的文件、日志文件、本地设置文件等。 克隆远程仓库： 1git clone [远程仓库地址] [本地目录名] //若不指明本地目录名则是在当前目录下 可选参数：\n-b [分支名]：克隆特定分支。 二、仓库管理 在 Git 中，如果你想添加或者更改远程仓库的 URL，你可以使用 git remote 命令来添加一个新的远程仓库或修改现有的远程仓库。以下是一些相关的命令和步骤：\n1.添加远程仓库 在本地仓库中，可以通过以下命令添加远程仓库：\n1git remote add [远程仓库名] [远程仓库地址] 例如，将名为origin的远程仓库设置为https://github.com/username/my_project.git：\n1git remote add origin https://github.com/username/my_project.git 2.更改现有远程仓库的： 如果你想要更改一个现有远程仓库的 URL，你可以先删除原来的远程仓库，然后添加一个新的远程仓库。 删除远程仓库：\n1git remote rm [远程仓库名] 然后，添加新的远程仓库：\n1git remote add [远程仓库名] [新的远程仓库地址] 3.查看远程仓库列表： 要查看所有已添加的远程仓库，可以使用以下命令：\n1git remote -v 这个命令会列出所有远程仓库的名称和 URL。 在进行远程仓库 URL 的更改时，请确保你的本地仓库中的所有更改都已经提交，并且与远程仓库同步。这样可以避免在更改 URL 过程中出现版本冲突或数据丢失的问题。如果你已经将更改推送到远程仓库，那么其他协作者可能无法通过旧的 URL 获取你的更改，因此你可能需要通知他们更新远程仓库的 URL。\n三、暂存并提交更改 1.暂存更改 git add 是 Git 版本控制系统中一个非常重要的命令，它的作用是将工作目录中的文件更改添加到暂存区（Staging Area），为下一次的提交做准备。\n1git add [file_path] //暂存特定文件或文件夹 2git add . //暂存所有更改 暂存更改是一个关键步骤，因为它决定了下一次 git commit 将会包含哪些更改。 2.查看暂存更改 查看暂存状态，这会告诉你哪些文件被暂存了，哪些文件还没有被暂存。\n1git status 3.提交更改 将更改提交到本地仓库，可以使用以下命令： 1git commit -m \u0026#34;[提交消息]\u0026#34; 可选参数：\n-a：提交所有已跟踪的文件。 --amend：修改最后一次提交。 --amend作用是对上一次的提交进行修改。这个命令会将暂存区中的更改添加到上一次提交中，而不是创建一个新的提交。 四、推送更改 要向远程仓库推送更改，你需要使用 git push 命令。以下是一些常用的 git push 命令和可选参数：\n基本推送：将本地分支的更改推送到远程仓库的对应分支。 1git push origin \u0026lt;分支名\u0026gt; 其中 \u0026lt;分支名\u0026gt; 是你想要推送的本地分支名，默认情况下，Git会将当前分支的更改推送到远程仓库中与之对应的同名分支。origin 是远程仓库的默认名称，但你可以根据需要更改它。\n如果你想要推送到远程仓库的其他分支，你需要指定远程分支的名称。例如，如果你想要将本地的 feature-branch 分支推送到远程仓库的 remote-feature-branch 分支，你可以这样做：\n1git push origin feature-branch:remote-feature-branch 在这个例子中，冒号前面的 feature-branch 是本地分支的名称，冒号后面的 remote-feature-branch 是远程分支的名称。\n如果你想要推送当前分支到远程仓库的一个不同名称的分支，你可以省略本地分支名称，只指定远程分支名称：\n1git push origin :remote-feature-branch 强制推送：使用 -f 或 --force 参数，可以强制推送，这会覆盖远程仓库中的历史记录。注意：这可能会丢失其他人的工作，因此请谨慎使用。 1git push -f origin \u0026lt;分支名\u0026gt; 删除远程分支：使用 --delete 参数，可以删除远程仓库中的分支。 1git push origin --delete \u0026lt;分支名\u0026gt; 跟踪分支：如果你刚刚克隆了一个仓库，并且想要推送一个新的分支到远程仓库，你可以使用 -u 或 --set-upstream 参数来设置跟踪分支。 1git push -u origin \u0026lt;分支名\u0026gt; 这样，以后你可以直接使用 git push 而不需要指定远程仓库和分支名。\n推送所有标签：如果你想推送所有本地标签到远程仓库，可以使用 --tags 参数。 1git push --tags dry run：使用 --dry-run 参数，可以模拟推送过程，但不会实际修改远程仓库。 1git push --dry-run origin \u0026lt;分支名\u0026gt; 安静模式：使用 -q 或 --quiet 参数，可以减少命令的输出。 1git push -q origin \u0026lt;分支名\u0026gt; 显示进度：使用 --progress 参数，可以显示推送的进度。 1git push --progress origin \u0026lt;分支名\u0026gt; 请记住，推送更改之前，通常需要先拉取远程仓库的最新更改，以避免冲突。你可以使用 git pull 命令来拉取远程分支的更新。\n1git pull origin \u0026lt;分支名\u0026gt; 在实际操作中，建议遵循团队的Git工作流程，并确保你的更改不会破坏其他人的工作。\n五、分支管理 1.创建新分支： 1git branch [分支名] 可选参数：\n-b：创建并切换到新分支。 2.切换分支： 1git branch //查看分支信息 2git branch -a //显示所有分支，包括远程分支 3git checkout [分支名] //切换分支 4git checkout -b [分支名] //创建并切换到新分支 3.合并分支： 1git merge [分支名] 可选参数：\n--no-ff：禁用快速前进合并。 六、撤销更改 1.撤销工作区更改： 1git checkout -- [文件名] 2.撤销提交： 1git reset --hard [提交哈希] 可选参数：\n--soft：保留工作区和暂存区的更改。 --mixed：保留工作区的更改（默认）。 --hard：不保留工作区和暂存区的更改。 七、版本回退 切换到历史版本： 1git checkout [提交哈希] 回退到历史版本 1git reset --hard [提交哈希] 可选参数：\n--soft：保留工作区和暂存区的更改。 --mixed：保留工作区的更改（默认）。 --hard：不保留工作区和暂存区的更改。 git checkout 命令用于切换分支或切换到特定的提交。git reset命令通常用于撤销提交，回到特定的旧版本，并且丢弃所有在指定提交之后所做的更改。 git checkout git reset 工作目录和暂存区 会保留工作目录和暂存区的更改 默认不保留暂存区的更改，保留工作区的更改，有\u0026ndash;soft,\u0026ndash;mixed,\u0026ndash;hard三种参数可选 用途 通常用于开发过程中的分支切换或历史版本切换 通常用于撤销提交或重置到特定的旧版本 强制推送更改： 1git push [远程仓库名] --force 2git push [远程仓库名] -f 可选参数：\n--set-upstream：将本地分支与远程分支关联。 八、查看和比较更改 1. 查看提交历史： 1git log 可选参数：\n--oneline：简化输出。 --graph：显示分支和合并的历史。 2. 查看文件更改： 1git diff [文件名] 九、保存当前的工作进度 git stash 命令用于暂时存储你的工作进度。当你需要暂时中断当前的工作，比如切换到另一个分支处理紧急问题，或者拉取远程仓库的最新代码，但又不想丢失当前的工作进度时，git stash 非常有用。 ①暂存当前工作进度：\n1git stash ②查看暂存列表：\n1git stash list ③应用暂存：\n1git stash apply ④删除暂存：\n1git stash drop ⑤清空暂存：\n1git stash clear 通过将这些命令按照类别进行整理，您可以更容易地找到并理解与您当前任务相关的Git命令。在使用Git时，建议从简单的命令开始，逐步学习并尝试更复杂的操作，以便更好地掌握Git的使用。\n","date":1708422142,"headings":[{"anchor":"1-查看提交历史","title":"1. 查看提交历史："},{"anchor":"1创建新分支","title":"1.创建新分支："},{"anchor":"1撤销工作区更改","title":"1.撤销工作区更改："},{"anchor":"1暂存更改","title":"1.暂存更改"},{"anchor":"1添加远程仓库","title":"1.添加远程仓库"},{"anchor":"2-查看文件更改","title":"2. 查看文件更改："},{"anchor":"2切换分支","title":"2.切换分支："},{"anchor":"2撤销提交","title":"2.撤销提交："},{"anchor":"2更改现有远程仓库的","title":"2.更改现有远程仓库的："},{"anchor":"2查看暂存更改","title":"2.查看暂存更改"},{"anchor":"3合并分支","title":"3.合并分支："},{"anchor":"3提交更改","title":"3.提交更改"},{"anchor":"3查看远程仓库列表","title":"3.查看远程仓库列表："},{"anchor":"一仓库初始化和克隆","title":"一、仓库初始化和克隆"},{"anchor":"七版本回退","title":"七、版本回退"},{"anchor":"三暂存并提交更改","title":"三、暂存并提交更改"},{"anchor":"九保存当前的工作进度","title":"九、保存当前的工作进度"},{"anchor":"二仓库管理","title":"二、仓库管理"},{"anchor":"五分支管理","title":"五、分支管理"},{"anchor":"八查看和比较更改","title":"八、查看和比较更改"},{"anchor":"六撤销更改","title":"六、撤销更改"},{"anchor":"四推送更改","title":"四、推送更改"}],"kind":"page","lang":"zh-hans","series":["环境配置"],"summary":"","title":"Git常用命令","url":"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","year":"2024"},{"content":"在软件开发的世界中，版本控制是一个至关重要的工具。它允许开发者保存、追踪和恢复代码的各个版本。Git由 Linus Torvalds 创建，是目前最受欢迎的版本控制系统之一。在这篇博客中，我们将探讨 Git 是什么，为什么它是分布式的，以及如何使用它进行开发者之间的协作。\n一、什么是 Git？ Git 是一个开源的分布式版本控制系统，用于追踪文件更改和帮助多人协作开发。它被设计成能够快速、高效地处理从很小到非常大的项目。 Git 的核心概念包括：\n仓库（Repository）： 仓库是 Git 中存储所有项目文件和相关元数据的地方。这些文件被称为“仓库”是因为它们存储了项目的完整历史和状态。仓库通常是一个目录，其中包含多个文件和子目录，以及指向这些文件的指针。仓库还包含一个名为.git的子目录，该子目录存储了所有的元数据和版本历史记录。 提交（Commit）： 提交是 Git 中保存项目状态的一种方式，它代表项目在特定时间点的快照。每次提交都会保存一组父提交（即之前的提交），以及指向这些父提交的指针。提交还包含一个提交者信息，如提交者的用户名和电子邮件地址，以及一个提交消息，描述了本次提交的内容。 注意仓库、提交、工作区、暂存区之间的区别，仓库、工作区、暂存区均为存储目录/存储空间，而提交为动作。工作区、暂存区之间的区别见下文标题四。 分支（Branch）： 分支是 Git 中并行开发的关键特性。一个分支代表了一个独立的代码路径，允许开发者在不同的代码路径上工作，而不会相互干扰。创建分支时，Git 会复制当前分支的提交历史，并创建一个新的分支指向最后一个提交的副本。之后，开发者可以在新的分支上进行更改，并提交新的提交。 合并（Merge）： 合并是将两个或多个分支的更改整合到一起的过程。当两个或多个开发者在同一时间段内对同一部分代码进行了更改，并且这些更改需要合并在一起时，就需要进行合并。Git 提供了一种自动合并更改的方法，它会尝试找出两个分支的共同祖先，并合并更改。 远程仓库（Remote）： 远程仓库是存储在网络上的 Git 仓库，允许团队成员协作。远程仓库通常托管在代码托管平台（如 GitHub、GitLab 或 Bitbucket）上。通过将本地仓库与远程仓库关联，开发者可以推送更改到远程仓库，并与他人共享。其他开发者可以从远程仓库克隆或拉取更改，以便协作和同步。 二、Git 是分布式的，这意味着什么？ 1.集中式版本控制系统 想象一个实体文件柜，里面有一个文件夹，包含所有项目文件。每当有人需要操作一个文件时，他们必须拿起它，从文件夹中取出，然后在完成工作后放回文件夹。因此为了避免任何可能的冲突，不可能让两个人同时工作在同一个文件上。\n这是集中式版本控制系统的工作方式，用户需要“检出”和“检入”文件，即当有人需要编辑特定文件时，他们需要检出该文件，从仓库中移除，然后在完成工作后检入文件，将其返回仓库。\n2.分布式版本控制系统 在像Git这样的分布式系统中，多个用户可以同时访问同一远程仓库的文件。每当有人需要编辑文件时，他们可以简单地将文件（或整个仓库）克隆到本地机器上，然后将修改后的文件推送到远程仓库。这样，多人可以同时工作在同一个项目上，甚至可以编辑同一个文件。\n这就是大型开源项目能够分布式的原因，来自世界各地的人们可以共同工作在同一个项目上，管理修改和可能的冲突（在这里也会发生合并冲突）。\n3.分布式的优势 Git 的分布式特性是其最强大的特点之一。在分布式系统中，每个开发者的工作站上都有一个完整的代码库副本，包括所有历史提交记录和版本信息。这意味着开发者可以在本地进行大多数操作，如提交、创建分支、合并等，而不需要连接到网络或中央服务器。\n去中心化： 在 Git 中，没有中央服务器或单一的权威源。每个开发者的工作站上都有一个完整的代码库，这意味着他们可以在没有网络连接的情况下继续工作。 这种去中心化的结构提高了系统的可靠性，因为没有任何单一的故障点。即使某个中央服务器出现问题，开发工作仍然可以继续。 性能优化： 大多数 Git 操作，如提交、创建分支和合并，都可以在本地执行。这大大提高了操作的速度和效率，特别是在处理大型项目时。 本地操作减少了网络延迟和中央服务器的负载，使得团队可以更快地迭代和协作。 安全性： Git 使用加密哈希来确保数据的完整性和一致性。每次提交都会生成一个唯一的哈希值，用于标识该提交。这使得检测数据是否被篡改变得非常容易。 分布式结构意味着每个开发者都有责任确保他们的工作站上的代码库是完整和可信的。 灵活性： 开发者可以在本地创建分支、提交更改，并在准备好后推送这些更改到远程仓库。这使得并行开发变得简单，因为多个开发者可以在同一时间处理不同的任务。 即使在网络不可用的情况下，开发者也可以继续工作，这确保了开发的连续性。 协作简单： 开发者可以通过简单的命令，如 git pull 和 git push，从远程仓库拉取和推送更改。这使得团队成员之间的协作和同步变得非常直接和高效。 通过特性分支和合并请求（pull requests），团队成员可以在本地工作，并在合并到主分支之前与他人共享和讨论更改。 数据完整性： Git 中的数据完整性是通过一系列的加密哈希来保证的。每次提交都会生成一个唯一的哈希值，用于标识该提交。这使得检测数据是否被篡改变得非常容易。 三、安装和配置git 安装和设置 Git 是一个简单的过程，可以通过以下步骤来完成。以下指南适用于 Windows、macOS 和 Linux 系统。\n1.在 Windows 上安装 Git 下载 Git： 访问 Git 官网 并下载适用于 Windows 的安装程序。\n安装 Git： 运行下载的安装程序，并按照安装向导的指示进行安装。\n配置： 安装完成后，你可以选择配置 Git。打开命令提示符或 PowerShell，运行以下命令来设置你的 Git 用户名和电子邮件地址：\n1git config --global user.name \u0026#34;Your Name\u0026#34; 2git config --global user.email \u0026#34;your_email@example.com\u0026#34; 这些设置将用于所有你通过 Git 进行的提交。\n2.在 macOS 上安装 Git 使用 Homebrew 安装 Git： macOS 用户可以使用 Homebrew 包管理器来安装 Git。首先，打开终端并运行以下命令来安装 Homebrew（如果尚未安装）：\n1/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; 然后，使用 Homebrew 安装 Git：\n1brew install git 配置： 安装完成后，你可以配置 Git。在终端中运行以下命令来设置你的 Git 用户名和电子邮件地址：\n1git config --global user.name \u0026#34;Your Name\u0026#34; 2git config --global user.email \u0026#34;your_email@example.com\u0026#34; 3.在 Linux 上安装 Git 使用包管理器安装 Git： Linux 发行版的包管理器中通常都包含 Git。以下是使用一些常见发行版包管理器的示例： Ubuntu/Debian: 1sudo apt-get update 2sudo apt-get install git Fedora: 1sudo dnf install git Arch Linux: 1sudo pacman -S git 配置： 安装完成后，你可以配置 Git。在终端中运行以下命令来设置你的 Git 用户名和电子邮件地址： 1git config --global user.name \u0026#34;Your Name\u0026#34; 2git config --global user.email \u0026#34;your_email@example.com\u0026#34; 4.验证 Git 安装 安装 Git 后，打开命令提示符、PowerShell、终端（macOS/Linux）并运行以下命令来验证 Git 是否正确安装：\n1git --version 如果 Git 已正确安装，这将显示安装的 Git 版本号。 现在你已经安装了 Git，你可以开始使用它来管理你的代码仓库了。记得，Git 是一个分布式版本控制系统，这意味着你可以在本地执行大多数操作，然后将更改推送到远程仓库与他人共享。\n四、git的工作区和暂存区 工作区（Working Directory） 工作区是你电脑上的一个目录，它包含了你正在工作的文件。你可以在这个目录中编辑文件、创建新文件或删除文件。工作区是Git中文件更改的起始点。当你第一次克隆一个仓库时，工作区会包含所有文件的最新版本。 暂存区/索引区（Staging Area） 暂存区是一个介于工作区和仓库之间的小型区域，它用于暂存即将进行的提交。当你使用 git add命令时，文件的更改会被添加到暂存区。暂存区允许你选择性地将更改组织成更小、更有意义的提交。你可以添加一部分文件的更改到暂存区，然后提交它们，而不必将所有更改都包含在一个提交中。 简而言之，工作区是你实际编辑文件的地方，而暂存区是你准备下一次提交的地方。当你准备好提交更改时，你会将工作区中已完成的更改添加到暂存区，然后一次性提交暂存区中的所有更改。 下面是一个简单的例子，展示了工作区和暂存区的使用过程： 1# 编辑工作区中的文件 2edit file1.txt 3# 将更改添加到暂存区 4git add file1.txt 5# 编辑另一个文件 6edit file2.txt 7# 只暂存file1.txt的更改，file2.txt的更改不包含在这次提交中 8git commit -m \u0026#34;Update file1.txt\u0026#34; 9# 现在将file2.txt的更改添加到暂存区 10git add file2.txt 11# 提交file2.txt的更改 12git commit -m \u0026#34;Update file2.txt\u0026#34; 在这个例子中，我们首先在工作区中编辑了 file1.txt，然后将其更改添加到暂存区，并提交了一个包含这些更改的 commit。接着，我们编辑了 file2.txt，但没有立即提交它。最后，我们将 file2.txt的更改添加到暂存区，并提交了一个新的 commit。这样，我们就有了两个独立的提交，每个提交都包含了不同的文件更改。\n","date":1708417795,"headings":[{"anchor":"1在-windows-上安装-git","title":"1.在 Windows 上安装 Git"},{"anchor":"1集中式版本控制系统","title":"1.集中式版本控制系统"},{"anchor":"2分布式版本控制系统","title":"2.分布式版本控制系统"},{"anchor":"2在-macos-上安装-git","title":"2.在 macOS 上安装 Git"},{"anchor":"3分布式的优势","title":"3.分布式的优势"},{"anchor":"3在-linux-上安装-git","title":"3.在 Linux 上安装 Git"},{"anchor":"4验证-git-安装","title":"4.验证 Git 安装"},{"anchor":"一什么是-git","title":"一、什么是 Git？"},{"anchor":"三安装和配置git","title":"三、安装和配置git"},{"anchor":"二git-是分布式的这意味着什么","title":"二、Git 是分布式的，这意味着什么？"},{"anchor":"四git的工作区和暂存区","title":"四、git的工作区和暂存区"}],"kind":"page","lang":"zh-hans","series":["环境配置"],"summary":"","tags":["git"],"title":"Git指南：版本控制的力量","url":"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/git-%E6%8C%87%E5%8D%97%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%9A%84%E5%8A%9B%E9%87%8F/","year":"2024"},{"content":"Hugo 不仅支持常见的命令来创建和预览网站，还提供了一些高级命令和选项\n一、引言 Hugo 是一个广受欢迎的静态网站生成器，它使用 Go 语言编写，以其快速生成站点和灵活的模板系统而闻名。Hugo 不仅支持常见的命令来创建和预览网站，还提供了一些高级命令和选项，这些高级功能可以帮助你更好地控制网站生成和预览过程。本文将详细介绍 Hugo 的基础命令以及一些少用的命令和选项，帮助你更高效地进行网站开发。\n二、Hugo 基础命令 1.新建站点 1hugo new site [sitename] 这个命令用于创建一个新的 Hugo 站点。它会生成一个包含基本结构的目录，其中包含配置文件、内容、布局等。\n2.新建内容 1hugo new [content]/[filename].md 用于在指定的内容目录下创建一个新的 Markdown 文件。Hugo 会自动添加一些前置matter（Front Matter）字段，如标题、日期等。\n3.构建站点 1hugo 这个命令会构建你的站点，将 Markdown 文件和其他资源转换为静态 HTML 文件。默认情况下，生成的文件会存放在 public 目录中。\n4.本地服务器 1hugo server 启动一个本地服务器，让你可以在浏览器中预览站点。这个命令还支持实时刷新功能，当你修改内容时，站点会自动重新构建和刷新。\n三、Hugo 服务器高级参数 Hugo 服务器命令是进行网站开发和预览的常用方式。以下是一些高级参数，它们可以帮助你更好地控制服务器行为：\n1.指定端口 1hugo server -p 7070 指定 Hugo 服务器监听的端口。例如，-p 7070 表示服务器将在本地主机的 7070 端口上运行。\n2.垃圾回收 1hugo server --gc 在 Hugo 服务器每次启动时，清理掉旧的模块缓存，确保使用的是最新的依赖版本。\n3.构建草稿 1hugo server --buildDrafts 构建并显示所有草稿内容。草稿是标记为未完成或不想立即发布的页面。使用这个参数，可以预览这些内容而不必公开发布。\n4.启用 Git 信息 1hugo server --enableGitInfo 在生成的 HTML 文件中包含 Git 信息，如提交哈希、作者、日期等。这要求你的 Hugo 网站是放在 Git 仓库中的。\n四、高级选项 Hugo 还提供了一些其他的高级选项，这些选项可能不经常使用，但在某些情况下它们会非常有用：\n1.渲染到磁盘 1hugo --renderToDisk 将Markdown文件渲染为HTML文件到磁盘上，而不是只保存在内存中。这对于大型站点或者需要将渲染后的文件与其他工具一起使用的场景很有帮助。\n2.国际化警告 1hugo --i18n-warnings 输出国际化（i18n）相关的警告。如果你的网站支持多语言，这个参数可以帮助你确保所有翻译都是完整的。\n3.模板指标 1hugo --templateMetrics 输出有关模板执行的指标，包括每个模板的渲染时间和调用次数。这对于优化站点性能非常有用。\n4.路径警告 1hugo --path-warnings 在生成站点时警告关于无效的链接和路径问题。这有助于确保你的站点没有死链或错误的URL。\n五、其他少用命令 除了上述的高级命令和选项外，Hugo 还有一些其他少用的命令，这些命令在某些特定场景下可能会非常有用：\n1.模块管理 1hugo mod [subcommand] 管理 Hugo 模块。模块是 Hugo 用来管理依赖项的一种方式，这个命令可以帮助你添加、更新或删除模块。\n2.文件生成 1hugo gen [subcommand] 生成不同类型的文件，如 XML、JSON 等。这个命令可以帮助你生成站点地图、RSS 订阅源等。\n六、 结论 通过探索 Hugo 的这些基础和高级命令，你可以更好地控制网站生成和预览过程，提高网站开发的效率和质量。无论你是 Hugo 新手还是经验丰富的开发者，了解这些命令和选项都可以为你的工作带来便利。希望本文能够帮助你更好地利用 Hugo 的强大功能，打造出色的静态网站。\n","date":1708410369,"headings":[{"anchor":"1指定端口","title":"1.指定端口"},{"anchor":"1新建站点","title":"1.新建站点"},{"anchor":"1模块管理","title":"1.模块管理"},{"anchor":"1渲染到磁盘","title":"1.渲染到磁盘"},{"anchor":"2国际化警告","title":"2.国际化警告"},{"anchor":"2垃圾回收","title":"2.垃圾回收"},{"anchor":"2文件生成","title":"2.文件生成"},{"anchor":"2新建内容","title":"2.新建内容"},{"anchor":"3构建站点","title":"3.构建站点"},{"anchor":"3构建草稿","title":"3.构建草稿"},{"anchor":"3模板指标","title":"3.模板指标"},{"anchor":"4启用-git-信息","title":"4.启用 Git 信息"},{"anchor":"4本地服务器","title":"4.本地服务器"},{"anchor":"4路径警告","title":"4.路径警告"},{"anchor":"一引言","title":"一、引言"},{"anchor":"三hugo-服务器高级参数","title":"三、Hugo 服务器高级参数"},{"anchor":"二hugo-基础命令","title":"二、Hugo 基础命令"},{"anchor":"五其他少用命令","title":"五、其他少用命令"},{"anchor":"六-结论","title":"六、 结论"},{"anchor":"四高级选项","title":"四、高级选项"}],"kind":"page","lang":"zh-hans","series":["hugo博客"],"summary":"Hugo 不仅支持常见的命令来创建和预览网站，还提供了一些高级命令和选项\n","tags":["hugo"],"title":"探索 Hugo 静态网站生成器的高级命令和选项","url":"/hugo%E5%8D%9A%E5%AE%A2/%E5%B8%B8%E7%94%A8%E7%9A%84hugo%E5%91%BD%E4%BB%A4/","year":"2024"},{"content":"短代码是Hugo中的一种自定义标记语法，它允许你在Markdown文件中插入预定义的HTML代码片段。\n什么是短代码 Hugo 中的短代码（Shortcodes）是一个强大的功能，它允许你在Markdown文件中插入自定义的HTML代码，而不必编写HTML标签。Hugo会在生成静态网站时将短代码替换为相应的HTML代码，这使得Markdown文件的编写更加简洁和直观，同时保持了内容的纯文本格式。\n在Hugo主题的模板文件中，短代码会被定义为一个函数，它接受参数并返回HTML代码。例如，一个简单的短代码函数可能如下所示：\n1\u0026lt;!-- shortcode-name.html --\u0026gt; 2\u0026lt;div\u0026gt; 3 \u0026lt;!-- 短代码的实现 --\u0026gt; 4\u0026lt;/div\u0026gt; 在Markdown文件中使用短代码时，Hugo会在生成静态网站时将短代码替换为相应的HTML代码。\nHugo内置短代码 Figure： 是 Markdown 中图像语法的延伸。 Gist：显示 GitHub gist 代码。 Highlight：显示高亮代码。 Param：获取当前页面的参数，如无则回退到网站参数。 ref and relref：返回指定页面的固定链接（ref）或相对固定链接（relref）。 Bootstrap 短代码 此为HB主题中内置的短代码\nBootstrap 短代码列表。\nAlert：显示警告信息，支持多种样式、图标和标题。 Clearfix：清除浮动的内容，如浮动图片。 Collapse：隐藏和显示内容。 Config Toggle：从一个代码库中生成一个配置切换，支持 YAML、TOML 和 JSON。 Icon Grid：显示带有图标、标题和描述的 icon grid。 Lead：使一个段落脱颖而出。 Ratio：完美的响应式处理视频或幻灯片的嵌入，基于父体的宽度。 Toggle：比 config toggle 更加通用，设计用于任何内容，如 SDK 代码。 详情请参考文章：短代码 - 内容 - 用户手册 - HB 框架 (hbstack.dev)\n","date":1708363960,"headings":[{"anchor":"bootstrap-短代码","title":"Bootstrap 短代码"},{"anchor":"hugo内置短代码","title":"Hugo内置短代码"},{"anchor":"什么是短代码","title":"什么是短代码"}],"kind":"page","lang":"zh-hans","series":["hugo博客"],"summary":"短代码是Hugo中的一种自定义标记语法，它允许你在Markdown文件中插入预定义的HTML代码片段。\n","title":"短代码","url":"/hugo%E5%8D%9A%E5%AE%A2/%E7%9F%AD%E4%BB%A3%E7%A0%81/","year":"2024"},{"content":"文档属性的内容及含意介绍\n一、内容原型 在 Hugo 中，archetypes 文件夹用于存储内容原型。内容原型是一些模板文件，当使用 hugo new 命令创建新内容时，它们会用作默认的前置元数据文件。这些原型文件通常包含了一些基础的前置元数据(文档属性)，如标题、日期和布局设置。\n在 Hugo 中，当你使用 hugo new 命令创建一个新的内容文件时，Hugo 会按照以下顺序来检索内容原型（archetypes）：\n检查内容类型：Hugo 会首先确定你要创建的内容的类型。这通常是通过你提供的命令参数来确定的，例如 hugo new post/my-new-post.md 会创建一个类型为 \u0026ldquo;post\u0026rdquo; 的新内容文件。 查找内容原型：一旦内容类型被确定，Hugo 会尝试在 archetypes 目录中查找与内容类型相匹配的原型文件。原型文件的命名通常是基于内容类型的，例如 archetypes/post.md。 应用默认原型：如果你没有为特定内容类型提供原型文件，Hugo 会退而求其次，查找一个名为 default.md 的默认原型文件。 使用原型创建内容：找到合适的原型文件后，Hugo 会使用它来创建新的内容文件。原型文件中的前置元数据会被插入到新内容文件的前置元数据部分。 提示用户输入：在某些情况下，Hugo 可能会提示用户输入缺失的前置元数据值，尤其是如果原型文件中包含了占位符。 生成新内容文件：最后，Hugo 会生成新的内容文件，并将其保存在指定的目录中。 例如，如果你运行命令 hugo new post/my-first-post.md，Hugo 会：\n确定内容类型为 \u0026ldquo;post\u0026rdquo;。 查找 archetypes/post.md 文件。 如果找到，使用 archetypes/post.md 中的前置元数据来创建 content/post/my-first-post.md 文件。 如果没有找到特定于 \u0026ldquo;post\u0026rdquo; 的原型文件，Hugo 会尝试使用 archetypes/default.md。 如果连默认原型文件都没有，Hugo 会创建一个没有前置元数据的新内容文件。 内容原型是一个非常有用的功能，因为它可以帮助你确保所有新创建的内容都包含必要的前置元数据，从而保持网站的一致性和组织性。 二、文档属性 1.文章属性 在HB主题中，包含以下文档属性（元数据）：\n属性 说明 title 文档的标题。 date 文档的创建或最后修改日期。 draft 一个布尔值，表示文档是否为草稿。如果设置为 true，则不会在生成网站时显示。 layout 定义了页面的布局。在 Hugo 中，这通常是一个文件夹或模板的名称。HB主题里可选landing落地窗布局，文章首页展示大图。 type 文档的类型或部分。在 Hugo 中，这通常用于组织内容。HB主题里可选docs和blog linkTitle 如果文档是一个系列的一部分，linkTitle 用于定义在导航中的显示名称。 nav_weight 定义了文档在导航菜单中的权重或排序。越小越靠前。 authors 文档的作者列表。 series 文档所属的专栏。 tag 文档的标签列表。 nav_icon 定义了文档在导航菜单中的图标。这通常是一个字体图标或图像。 vendor 图标的来源库或框架名称。例如，bs 可能指的是 Bootstrap。nav_icon的子属性。 name 图标的名称。nav_icon的子属性。 menu （可选）在导航栏菜单栏名称，图标的设置 这些属性在 Hugo 博客中用于定义和自定义文档的各个方面，包括其结构、外观和导航菜单中的显示方式。\n2.导航栏属性 特别的关于menu属性：\n在 Hugo 主题中，menu 是一个用于定义导航菜单的结构，它允许您自定义菜单的布局、内容和外观。以下是 menu 属性及其含义的表格：\n属性 说明 main 定义主菜单的配置。 parent 定义菜单项的父容器。在 Hugo 中，这通常是一个布局文件或模板。 weight 定义菜单项的权重或排序。数值越小，菜单项在列表中的位置越靠前。 params 一个对象，用于定义菜单项的额外参数。这些参数可以用于自定义菜单项的显示和行为。 description 菜单项的描述文本，通常用于工具提示或菜单项的附加信息。 icon 定义菜单项的图标。这通常是一个字体图标或图像。 vendor 图标的来源库或框架名称。例如，bs 可能指的是 Bootstrap。 name 图标的名称。 className 添加到图标元素的类名，可以用于进一步自定义图标的外观。 color 图标的颜色 例如，以下是一个 Hugo 主题中 menu 部分的示例配置：\n1menu: 2 main: 3 parent: column 4 weight: 2 5 params: 6 description: 环境配置 7 icon: 8 vendor: bs 9 name: toggles 10 className: text-primary 11 # color: blue 在这个例子中，main 菜单项被定义为 column 布局的子元素，具有 2 的权重。params 对象包含了菜单项的描述和图标配置，其中图标来自 Bootstrap 框架，名称为 toggles，并且添加了一个名为 text-primary 的类名。 这些属性在 Hugo 主题的配置文件中用于定义和自定义菜单的各个方面，包括其结构、外观和导航菜单中的显示方式。\n三、图标 尽管图标的根参数不同，如 icon 或 nav_icon，但成员参数是相同的。\n1.成员参数 vendor\n图标供应商名称，默认支持 bootstrap（bs），要使用其他供应商，需要导入相应的模块，以 Font Awesome 图标为例。\nhugo.yaml\n1module: 2 imports: 3 - path: github.com/hugomods/icons/vendors/font-awesome 现在你可以使用 Font Awesome 实体（fas）、常规（far）和品牌（fab）图标了。\nname\n图标的名称，如 book、house。\ncolor\n图标的十六进制颜色，如 green, #7952B3。\nclassName\n图标样式的附加类名，如 text-success、text-primary。\n1\u0026lt;p class=\u0026#34;text-primary\u0026#34;\u0026gt;.text-primary\u0026lt;/p\u0026gt; 2\u0026lt;p class=\u0026#34;text-secondary\u0026#34;\u0026gt;.text-secondary\u0026lt;/p\u0026gt; 3\u0026lt;p class=\u0026#34;text-success\u0026#34;\u0026gt;.text-success\u0026lt;/p\u0026gt; 4\u0026lt;p class=\u0026#34;text-danger\u0026#34;\u0026gt;.text-danger\u0026lt;/p\u0026gt; 5\u0026lt;p class=\u0026#34;text-warning\u0026#34;\u0026gt;.text-warning\u0026lt;/p\u0026gt; 6\u0026lt;p class=\u0026#34;text-info\u0026#34;\u0026gt;.text-info\u0026lt;/p\u0026gt; 7\u0026lt;p class=\u0026#34;text-light bg-dark\u0026#34;\u0026gt;.text-light\u0026lt;/p\u0026gt; 8\u0026lt;p class=\u0026#34;text-dark\u0026#34;\u0026gt;.text-dark\u0026lt;/p\u0026gt; 9\u0026lt;p class=\u0026#34;text-muted\u0026#34;\u0026gt;.text-muted\u0026lt;/p\u0026gt; 10\u0026lt;p class=\u0026#34;text-white bg-dark\u0026#34;\u0026gt;.text-white\u0026lt;/p\u0026gt; 2.供应商Vendor Vendor Vendor Name Shorthand Module Path Bootstrap Icons bootstrap bs github.com/hugomods/icons/vendors/bootstrap Feather Icons feather - github.com/hugomods/icons/vendors/feather Font Awesome Brands Icons font-awesome-brands fab github.com/hugomods/icons/vendors/font-awesome Font Awesome Regular Icons font-awesome-regular far github.com/hugomods/icons/vendors/font-awesome Font Awesome Solid Icons font-awesome-solid fas github.com/hugomods/icons/vendors/font-awesome Lucide Icons lucide - github.com/hugomods/icons/vendors/lucide Material Design Icons mdi - github.com/hugomods/icons/vendors/mdi Simple Icons simple-icons simple github.com/hugomods/icons/vendors/simple-icons Tabler Icons tabler - github.com/hugomods/icons/vendors/tabler 3.图标搜索 所有可用的图标都可以在 Hugo Icons Module 上找到\n也可在官网查询\nBootstrap Icons :Bootstrap 图标库 · Bootstrap 官方开源图标（icon）库 (bootcss.com) Simple Icons:Simple Icons ","date":1708359820,"headings":[{"anchor":"1成员参数","title":"1.成员参数"},{"anchor":"1文章属性","title":"1.文章属性"},{"anchor":"2供应商vendor","title":"2.供应商Vendor"},{"anchor":"2导航栏属性","title":"2.导航栏属性"},{"anchor":"3图标搜索","title":"3.图标搜索"},{"anchor":"一内容原型","title":"一、内容原型"},{"anchor":"三图标","title":"三、图标"},{"anchor":"二文档属性","title":"二、文档属性"}],"kind":"page","lang":"zh-hans","series":["hugo博客"],"summary":"文档属性的内容及含意介绍\n","title":"文档属性","url":"/hugo%E5%8D%9A%E5%AE%A2/%E6%96%87%E6%A1%A3%E5%B1%9E%E6%80%A7/","year":"2024"},{"content":"关于markdown语法的速查\nMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成结构化的 HTML 文档。Markdown 语法简洁明了，易于学习，因此在程序员和写作者中广受欢迎。下面将详细介绍 Markdown 的基本语法。\n标题 Markdown 支持六级标题，分别使用 # 符号表示。# 的数量代表标题的级别。\n1# 一级标题 2## 二级标题 3### 三级标题 4#### 四级标题 5##### 五级标题 6###### 六级标题 段落与换行 段落之间使用一个或多个空行分隔。如果需要在段落内强制换行，可以在行尾添加两个或更多的空格然后回车。\n1这是一个段落。 2这是另一个段落。 强调 斜体 ：将文字包围在 * 或 _ 符号之间。 粗体 ：将文字包围在 ** 或 __ 符号之间。 粗斜体 ：将文字包围在 *** 或 ___ 符号之间。 列表 无序列表使用 *、+ 或 - 作为列表标记。 有序列表使用数字后跟英文句点。 1- 无序列表项一 2- 无序列表项二 3- 无序列表项三 4 51. 有序列表项一 62. 有序列表项二 73. 有序列表项三 链接与图片 链接：使用 [文本](链接地址 \u0026quot;标题\u0026quot;) 的格式。 图片：使用 ![替代文本](图片地址 \u0026quot;标题\u0026quot;) 的格式。 1[这是一个链接](https://www.example.com \u0026#34;示例网站\u0026#34;) 2![这是一张图片](https://www.example.com/image.jpg \u0026#34;示例图片\u0026#34;) 引用 使用 \u0026gt; 符号表示引用，符号后需紧跟一个空格。\n1\u0026gt; 这是一个引用。 代码 行内代码：使用一对反引号 ` 包围代码。 代码块：使用三个反引号 ``` 包围代码，并可选指定语言。 1`这是行内代码` 2 3```python 4这是代码块 表格 使用 | 和 - 来创建表格。\n1| 标题1 | 标题2 | 标题3 | 2|-------|-------|-------| 3| 单元格1 | 单元格2 | 单元格3 | 4| 单元格4 | 单元格5 | 单元格6 | 标题1 标题2 标题3 单元格1 单元格2 单元格3 单元格4 单元格5 单元格6 分隔线 使用三个或更多的 *、- 或 _ 来创建分隔线。\n1--- HTML 元素 Markdown 支持直接插入 HTML 元素。\n1\u0026lt;p\u0026gt;这是一个 HTML 段落。\u0026lt;/p\u0026gt; 自动链接 使用 \u0026lt; 和 \u0026gt; 包围 URL 或邮箱地址，自动生成链接。\n1\u0026lt;https://www.example.com\u0026gt; 以上是 Markdown 的基本语法指南，掌握这些基本用法后，可以更高效地编写文档和博客。Markdown 的简洁性和易用性使其成为文本处理的理想选择。\n","date":1708358595,"headings":[{"anchor":"html-元素","title":"HTML 元素"},{"anchor":"代码","title":"代码"},{"anchor":"分隔线","title":"分隔线"},{"anchor":"列表","title":"列表"},{"anchor":"引用","title":"引用"},{"anchor":"强调","title":"强调"},{"anchor":"标题","title":"标题"},{"anchor":"段落与换行","title":"段落与换行"},{"anchor":"自动链接","title":"自动链接"},{"anchor":"表格","title":"表格"},{"anchor":"链接与图片","title":"链接与图片"}],"kind":"page","lang":"zh-hans","series":["hugo博客"],"summary":"关于markdown语法的速查\n","tags":["markdown"],"title":"Markdown语法","url":"/hugo%E5%8D%9A%E5%AE%A2/markdown%E8%AF%AD%E6%B3%95/","year":"2024"},{"content":"本博客平台使用到的技术，hugo和HB框架的安装使用\n一、简介 我在大四寒假期间搭建了这个博客平台，这个专栏记录了我搭建这个博客平台的过程，并且汇集了一些使用HB框架写文章时经常用到的函数或者说方法，方便查阅。\n这个网站是基于hugo框架搭建的静态博客 主题是HB Framework 网站托管在github page上 使用自定义域名yaoyifeng.top 使用腾讯云的cdn来加快国内的访问速度 二、环境安装 1.安装hugo Hugo 是一个广受欢迎的静态网站生成器，由 Go 语言编写。它能够将Markdown、HTML等格式的文件和模板转换为静态网页。Hugo 以其快速生成网站的能力而闻名，这使得它成为许多开发者和博客作者的首选工具。 安装 Hugo 的方法取决于操作系统。以下是几种常见操作系统的安装步骤：\nWindows\n访问 Hugo 的 GitHub 发布页面。 下载适合你系统的 .exe 文件（例如 hugo_extended_0.111.3_windows-amd64.zip）。 解压下载的文件，并将 hugo.exe 文件移动到一个在系统 PATH 环境变量中的目录下，这样你就可以在命令行中全局访问 Hugo 命令。 打开命令提示符或 PowerShell，输入 hugo version 来验证安装是否成功。 HB 使用 Hugo Pipes 来编译 SCSS，因此需要扩展版（extended）的 Hugo。 建议将hugo.exe添加到系统/用户环境变量中，否则只能在当前目录下访问hugo，给使用带来不便 macOS\n打开终端。 使用 Homebrew 安装 Hugo。如果尚未安装 Homebrew，请先安装它。安装 Homebrew 后，输入以下命令： 1brew install hugo 安装完成后，输入 hugo version 来验证安装是否成功。 Linux\n打开终端。 使用包管理器安装 Hugo。例如，在 Ubuntu 或 Debian 上，可以使用以下命令： 1sudo apt-get install hugo 安装完成后，输入 hugo version 来验证安装是否成功。 通过 Go 语言安装 如果已经安装了 Go 语言环境，也可以通过以下命令安装 Hugo：\n1go install github.com/gohugoio/hugo@latest 安装完成后，应该能够通过在命令行中输入 hugo 来访问 Hugo 命令。\n2.安装go 一般来说使用hugo时并不需要使用go，但我用的HB Framework主题是一个模块化的框架，需要使用go语言来下载和更新hugo模块，具体见HB - Hugo Bootstrap 框架 (hbstack.dev)\n要下载和安装 Go 语言（也称为 Golang），请遵循以下步骤。请注意，步骤可能会因您的操作系统而异。\nWindows\n访问 Go 官方下载页面。 根据系统是 32 位还是 64 位，下载相应的 .msi 安装包。 运行下载的 .msi 文件，并按照安装向导的指示完成安装。 安装过程中，确保将 Go 安装路径添加到系统环境变量的 PATH 中。 安装完成后，重启任何已打开的命令提示符或 PowerShell 窗口。 在命令行中输入 go version 来验证安装是否成功。 同安装hugo一样，安装go不会自动将安装路径添加到环境变量里，需要手动添加 macOS\n访问 Go 官方下载页面。 下载适用于 macOS 的 .pkg 安装包。 打开下载的 .pkg 文件，并按照安装向导的指示完成安装。 安装完成后，在终端中输入 go version 来验证安装是否成功。 Linux\n访问 Go 官方下载页面。 下载适用于 Linux 的 .tar.gz 压缩包。 打开终端，切换到您想要安装 Go 的目录（例如 cd /usr/local）。 使用 tar 命令解压下载的文件，例如： 1sudo tar -C /usr/local -xzf go$VERSION.$OS-$ARCH.tar.gz 将 $VERSION、$OS 和 $ARCH 替换为适当的值，例如 go1.18.3.linux-amd64.tar.gz。 将 Go 的 bin 目录添加到 PATH 环境变量中。可以通过修改 ~/.profile 或 ~/.bashrc 文件来实现这一点，例如： 1export PATH=$PATH:/usr/local/go/bin 在终端中输入 source ~/.profile 或 source ~/.bashrc 来更新当前会话的环境变量。 输入 go version 来验证安装是否成功。 3.安装git 关于git的介绍，安装使用方法详见环境配置专栏\n4.安装node.js 要求 Node.js 16 或后续版本。\nWindows\n访问 Node.js 官方网站 nodejs.org。 下载适合系统的安装包（建议选择 LTS 版本，因为它更稳定）。 运行下载的安装程序 .msi 文件。 按照安装向导的指示完成安装。默认情况下，安装程序会自动将 Node.js 添加到系统路径中。 安装完成后，打开命令提示符或 PowerShell。 输入 node -v 和 npm -v 来验证 Node.js 和 npm 是否正确安装。 node.js安装过程中会自动添加到系统环境变量中，无需手动添加 macOS\n访问 Node.js 官方网站 nodejs.org。 下载适合系统的安装包（建议选择 LTS 版本）。 打开下载的 .pkg 文件。 按照安装向导的指示完成安装。 安装完成后，打开终端。 输入 node -v 和 npm -v 来验证 Node.js 和 npm 是否正确安装。 Linux\n对于大多数 Linux 发行版，可以使用包管理器来安装 Node.js，以下是一些示例：\n使用 Ubuntu 或 Debian 的 apt-get：\n1curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash - 2sudo apt-get install -y nodejs 使用 CentOS 或 Fedora 的 yum：\n1curl -sL https://rpm.nodesource.com/setup_14.x | sudo bash - 2sudo yum install -y nodejs 使用 Arch Linux 的 pacman：\n1sudo pacman -S nodejs npm 安装完成后，打开终端并输入 node -v 和 npm -v 来验证 Node.js 和 npm 是否正确安装。\n使用 nvm (Node Version Manager)\n如果需要管理多个 Node.js 版本，可以使用 nvm（Node Version Manager）\n安装 nvm：\n对于 macOS 和 Linux，可以使用以下命令：\n1curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash 2# 或 3wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash 对于 Windows，可以使用 nvm-windows。\n使用 nvm 安装 Node.js：\n1nvm install node # 安装最新版本 2nvm install --lts # 安装 LTS 版本 3nvm use node # 使用已安装的最新版本 4nvm use --lts # 使用已安装的 LTS 版本 安装完成后，可以通过输入 node -v 和 npm -v 来验证 Node.js 和 npm 是否正确安装。\n安装node.js包 HB 依赖以下 Node.js 包。\n名称 描述 PostCSS CLI 用于转变样式。 RTLCSS 将 LTR CSS 转换为 RTL，如果你没有 RTL 网站则可选。 Autoprefixer 解析 CSS 并在 Can I Use 规则中添加对应的前缀。 PurgeCSS 移除未使用的 CSS。 NPM 已被包含于 Node.js 安装中，你可以选择局部或全局地安装这些包。\n局部安装 1npm i -D postcss-cli @fullhuman/postcss-purgecss autoprefixer rtlcss 局部安装将依赖写入 package.json，以便部署时通过 npm i 安装这些包，而无需记住这些繁杂的包名。\n全局安装 1sudo npm i -g postcss-cli @fullhuman/postcss-purgecss autoprefixer rtlcss 该命令只需执行一次，后续的 HB 站点无需再次执行此命令。\n两者都是有效的，HB 会优先局部查找需要的包。\n三、HB主题安装 1.克隆仓库 1git clone --depth 1 https://github.com/hbstack/theme blog 2cd blog 其中的 blog 是本地目录名称，请随意修改。\n2.修改模块路径 首先修改位于 go.mod 的模块路径，将其中的 module github.com/hbstack/theme 替换为你的，如：module github.com/user/repo。\n11sed -i -e \u0026#39;s/module\\ github.com\\/hbstack\\/theme/module\\ github.com\\/user\\/repo/\u0026#39; go.mod 3.提交改动到本地仓库 1git add . 2git commit --amend 修改提交信息保存即可，如：First commit。\n4.修改远程仓库 1git remote set-url origin https://github.com/user/repo 5.推送 1git push origin main 四、Hugo 模块代理 Go 官方的模块代理服务器于国内是无法正常使用的。不过可以通过设置代理服务器解决，本文将列出一些可用的 Go 代理服务器。而这也同样适用于 Hugo 模块。\n代理服务器 URL GOPROXY.CN (七牛云) https://goproxy.cn/ GOPROXY.IO https://goproxy.io/ 阿里云 https://mirrors.aliyun.com/goproxy/ 腾讯云 https://mirrors.tencent.com/go/ 下面给出在windows上设置代理服务器的方法：\n1$env:GOPROXY = \u0026#34;https://goproxy.cn/,direct\u0026#34; 2$env:HUGO_MODULE_PROXY = \u0026#34;https://goproxy.cn/,direct\u0026#34; 五、启动 Hugo 服务器 1.安装构建工具 1npm ci 2.启动hugo服务器 于开发模式下预览\n1npm run dev 于生产模式下预览\n1npm run prod package.json文件里面记录了npm所能运行的脚本\n{ \u0026#34;devDependencies\u0026#34;: { \u0026#34;glob\u0026#34;: \u0026#34;^10.3.10\u0026#34;, \u0026#34;prettier\u0026#34;: \u0026#34;^3.0.0\u0026#34;, \u0026#34;prettier-plugin-go-template\u0026#34;: \u0026#34;^0.0.15\u0026#34; }, \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;hugo server -p 7070 --gc --buildDrafts --enableGitInfo\u0026#34;, \u0026#34;prod\u0026#34;: \u0026#34;npm run clean \u0026amp;\u0026amp; hugo server -e production --minify --gc --renderToDisk --disableFastRender --enableGitInfo -b http://localhost:7080 -p 7080\u0026#34;, \u0026#34;docker\u0026#34;: \u0026#34;docker run -v $PWD:/src -p 7070:7070 -p 7071:7071 -p 7072:7072 hugomods/hugo:exts hugo server --bind 0.0.0.0 -p 7070\u0026#34;, \u0026#34;docker-prod\u0026#34;: \u0026#34;docker run -v $PWD:/src -p 7080:7080 -p 7081:7081 -p 7082:7082 hugomods/hugo:exts hugo server --bind 0.0.0.0 -e production --minify --gc --renderToDisk --disableFastRender --enableGitInfo -b http://localhost:7080 -p 7080\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;hugo --gc --minify --enableGitInfo\u0026#34;, \u0026#34;clean\u0026#34;: \u0026#34;del hugo_stats.json \u0026amp;\u0026amp; rmdir /s /q public\u0026#34;, \u0026#34;clean-build\u0026#34;: \u0026#34;npm run clean \u0026amp;\u0026amp; npm run build\u0026#34;, \u0026#34;update\u0026#34;: \u0026#34;hugo mod get -u \u0026amp;\u0026amp; hugo mod tidy\u0026#34;, \u0026#34;translate\u0026#34;: \u0026#34;node ./scripts/translate.js\u0026#34;, \u0026#34;decap-server\u0026#34;: \u0026#34;npx decap-server\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;@fullhuman/postcss-purgecss\u0026#34;: \u0026#34;^5.0.0\u0026#34;, \u0026#34;autoprefix\u0026#34;: \u0026#34;^1.0.1\u0026#34;, \u0026#34;autoprefixer\u0026#34;: \u0026#34;^10.4.13\u0026#34;, \u0026#34;postcss-cli\u0026#34;: \u0026#34;^10.1.0\u0026#34;, \u0026#34;postcss-purgecss\u0026#34;: \u0026#34;^5.0.0\u0026#34;, \u0026#34;rtlcss\u0026#34;: \u0026#34;^4.0.0\u0026#34; } } Hugo Server 生产模式的必要参数\n若需要在生产模式下使用 Hugo Server，需要指定 --disableFastRender 和 --renderToDisk，否则 PurgeCSS 和 PostCSS 会出现意想不到的问题。\n1hugo server \\ 2 --disableFastRender \\ 3 --renderToDisk \\ 4 -e production \\ 5 -b http://localhost:1314 \\ 6 -p 1314 ","date":1708353009,"headings":[{"anchor":"1克隆仓库","title":"1.克隆仓库"},{"anchor":"1安装hugo","title":"1.安装hugo"},{"anchor":"1安装构建工具","title":"1.安装构建工具"},{"anchor":"2修改模块路径","title":"2.修改模块路径"},{"anchor":"2启动hugo服务器","title":"2.启动hugo服务器"},{"anchor":"2安装go","title":"2.安装go"},{"anchor":"3安装git","title":"3.安装git"},{"anchor":"3提交改动到本地仓库","title":"3.提交改动到本地仓库"},{"anchor":"4修改远程仓库","title":"4.修改远程仓库"},{"anchor":"4安装nodejs","title":"4.安装node.js"},{"anchor":"5推送","title":"5.推送"},{"anchor":"一简介","title":"一、简介"},{"anchor":"三hb主题安装","title":"三、HB主题安装"},{"anchor":"二环境安装","title":"二、环境安装"},{"anchor":"五启动-hugo-服务器","title":"五、启动 Hugo 服务器"},{"anchor":"四hugo-模块代理","title":"四、Hugo 模块代理"}],"kind":"page","lang":"zh-hans","series":["hugo博客"],"summary":"本博客平台使用到的技术，hugo和HB框架的安装使用\n","tags":["hugo"],"title":"简介\u0026安装","url":"/hugo%E5%8D%9A%E5%AE%A2/%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85/","year":"2024"},{"content":"油猴可以帮你干什么：全网VIP视频，下载全网音乐，右键复制限制解除，百度文库下载……\n一、前提准备：edge浏览器 要下载油猴，那首先不得不提的就是微软2020年发布的新款edge浏览器，edge是真香真香！有了edge再也不用Chrome了。edge浏览器让能登陆微软拓展商店和Chrome拓展商店，可以使用Tampermonkey等等功能丰富的拓展。什么是拓展插件呢，拓展插件就是可以让你个性化定义自己浏览器的工具，让你的浏览器超乎你想象。\nwin10系统的电脑会自带老版edge浏览器，你要把它首先升级到最新版，如果不是win10系统的电脑直接下载最新版edge浏览器就可。升级与下载操作都在edge官方网站上进行即可\n官网上会有这个浏览器的功能介绍，往下翻会有下载或更新入口。下载或更新完成后会在桌面创立一个快捷方式图标\n二、油猴的下载安装 双击桌面图标打开新版edge浏览器后，点击右上角的…，再点击拓展\n我浏览器已经下载了好多插件，所以右侧是满满的，大家的右侧应该是空空如也，点击获取Microsoft Edge拓展即可。\n然后会进入到如下页面\n然后网页下翻找到Tampermonkey\n或者直接搜索Tampermonkey\n点击图标进入后再点击获取\n再点击添加拓展\n成功后浏览器工具栏会出现这个标志\n出现这个图标即是成功安装好了，如果没有出现这个图标的话打开拓展页面，点击右侧开关打开\n这就安装好了脚本管理器，但我们还没有脚本，下一步就是安装相应脚本\n三、脚本的安装使用 一般人会直接给你油猴脚本网站地址去安装相应脚本，但我想先推荐个新建标签的拓展插件，通过这个你可以探索好多好玩有趣的网站\n按同样的方式添加拓展并启用后就可，这个可以自定义你的网址导航主页（要首先关掉电脑管家或杀毒软件的锁定浏览器主页）\n它会推荐很多有用的网址，比如拓展迷等等，也具有十分强大的网址搜索能力，点击右上角的无限符号\n然后搜索油猴脚本，点击打开\n即进入这个网站\n你可以随意查找或搜索自己想要的脚本安装并使用，一般脚本安装页都会有相应脚本的使用方法。我随便点击一个打开，下翻网页即会有使用说明，点击安装此脚本及进入安装页面\n然后点击安装即可\n安装完成后鼠标左键点击油猴图标，点击管理面板，查看相应脚本是否安装成功，是否启用。已启用开关打开即大功告成。\n如果你觉得这上的脚本不能满足你的需求，你也可以自己写脚本来满足自己的特定需求。\n因本人水平有限，只是一点经验之谈，如有错误请多多指教。（懵懂大一计算机学生突发奇想写此博客 ）\n","date":1708002462,"headings":[{"anchor":"一前提准备edge浏览器","title":"一、前提准备：edge浏览器"},{"anchor":"三脚本的安装使用","title":"三、脚本的安装使用"},{"anchor":"二油猴的下载安装","title":"二、油猴的下载安装"}],"kind":"page","lang":"zh-hans","series":["环境配置"],"summary":"","tags":["浏览器"],"title":"油猴脚本管理器的超详细下载安装使用教程——新手必看","url":"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E7%8E%A9%E6%9C%BA%E6%8A%80%E5%B7%A7/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC/","year":"2024"},{"content":"PyTorch环境搭建（windows版）\n首先确定自己电脑上是否有nvidia的显卡（就是游戏显卡RTX3050，RTX3060\u0026hellip;\u0026hellip;这些，必须是nvidia的显卡）\n如果自己电脑上没有显卡，就配置cpu版的pytorch即可。安装cpu版的pytorch参考步骤1，4，如果自己电脑上有gpu,就安装gpu版的pytorch，参考步骤1，2，3。\n1.Anaconda安装 anaconda是python的包管理器，可以很方便的管理不同项目的python环境，解决不同项目python包的环境冲突问题。\nTIPS：我们做python项目时要养成良好的习惯，不同的python项目要采取不同的python虚拟环境，不同的虚拟环境之间相互隔离，python版本和包均不共用。python虚拟环境的创建和管理常用anaconda。 安装步骤： 1、官网下载安装包：https://www.anaconda.com/distribution/ 2、运行并选择安装路径，等待安装完成。(要记得勾选 Add Anaconda to the system PATH environment variable，是为了将Anaconda添加到环境变量中。是的它显示不建议你这样做，但我建议你这样做，要不然还要自己手动把他添加到环境变量里)\n3、查看是否安装成功，cmd中输入conda回车，是否出现如下信息，有则说明安装成功。\n2.CUDA与CuDNN安装 (1)先检查自己的电脑所支持的CUDA版本是多少。 桌面右键点击进去NVIDIA控制面板，找到左下角的系统信息，点击组件，出现如下界面。\n从NVCUDA.DLL 这一行后面的CUDA 11.4说明我的电脑所支持的最高版本是11.4。\n(2)官网下载相对应的CUDA (https://developer.nvidia.com/cuda-toolkit-archive)\n我所支持的版本是11.4，所以我下载的是红色箭头所标出的那行。点击以后出现如下页面，选择第一个下载即可。\n下载完成后，在所在的文件夹下运行安装即可。 然后查看CUDA是否安装成功： cmd中运行到安装的文件目录下：\n1cd C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\bin 然后执行nvcc -V，查看是否出现如下信息，有则说明CUDA安装成功。\n如果输入nvcc -V 出现错误，考虑是否将Anaconds加入环境变量PATH中。\n(3)安装相对应版本的cuDNN。 进入官网： https://developer.nvidia.com/rdp/cudnn-download 需要注册并登录账号（这个需要一段时间），然后选择相对应的版本下载。\n我的是CUDA11.4，所以我选择的是第一个。等待下载完成后进行解压，得到一个cuda文件夹，进入之后，全选，复制到之前CUDA所安装的文件夹下，有重复的进行替换即可。\n查看cuDNN是否安装成功： 步骤如下：（进入安装的路径）\n出现如下Result = PASS 说明cuDNN安装成功。 可以再接着执行deviceQuery.exe，如果出现Result = PASS 说明CUDA和cuDNN都已经安装成功了。\n3.gpu版Pytorch安装 （1）先配置torch环境。 先打开Anaconda Prompt(anaconda)\n下面我们分析一下anaconda prompt每一条命令行的结构。（base）指的是当前所在的python环境是base环境。C:UsersYYF\u0026gt;指的是当前anaconda prompt所在的文件夹位置，我们要执行相关指令只需要在\u0026gt;后面输入指令，回车运行即可。\n然后我们然后输入\n1conda env list 这条语句会显示出当前已存在的python虚拟环境，如果是刚安装anaconda,应该只有一个base基环境。 下面我们新建立一个python虚拟环境(命名为new)\n1conda create –n new python=3.9.10 -n就相当于参数\u0026ndash;name,上面这条语句也可改为conda create \u0026ndash;name python=3.9.10 (这儿python=xxx可以自己指定python版本，这儿的new是你所创建的虚拟环境的名称，大家可以自己取) 然后激活环境： 在anaconda prompt中输入：\n1conda activate new 此时我们可以看到（）里面已经变为new，说明我们已经进入new这个虚拟环境。\n此时再进行python包的安装就是对这个虚拟环境操作，比如我们 pip install numpy（或者 conda install numpy）,再输入\n1conda list # 显示当前虚拟环境的所有包环境 此时我们看到new这个虚拟环境里面已经有numpy这个包了。\n（2）pytorch的安装\n法一：打开pytorch官网：https://pytorch.org/get-started/locally/（pytorch当前建议版本）或者 https://pytorch.org/get-started/previous-versions/ （pytorch的老版本）找到自己所对应版本的使用conda命令安装即可（会慢一些，但建议新手这样做）。\n法二：进入如下网址：https://download.pytorch.org/whl/torch_stable.html，下载自己所需要的torch和torchvision。 可以按快捷键ctrl+F进行搜索。 （不建议新手这样做）\n（3）等待安装完成。 查看pytorch环境是否安装成功：\n要记得先进入之前创建的环境中，然后依次输入蓝色方格中的代码，没有报错，且最后输出True，则说明pytorch环境安装完成。\n4.cpu版PyTorch安装 （1）先配置torch环境。 先打开Anaconda Prompt(anaconda)\n下面我们分析一下anaconda prompt每一条命令行的结构。（base）指的是当前所在的python环境是base环境。C:UsersYYF\u0026gt;指的是当前anaconda prompt所在的文件夹位置，我们要执行相关指令只需要在\u0026gt;后面输入指令，回车运行即可。\n然后我们然后输入\n1conda env list 这条语句会显示出当前已存在的python虚拟环境，如果是刚安装anaconda,应该只有一个base基环境。 下面我们新建立一个python虚拟环境(命名为new)\n1conda create –n new python=3.9.10 -n就相当于参数\u0026ndash;name,上面这条语句也可改为conda create \u0026ndash;name python=3.9.10 (这儿python=xxx可以自己指定python版本，这儿的new是所创建的虚拟环境的名称) 然后激活环境： 在anaconda prompt中输入：\n1conda activate new 此时我们可以看到（）里面已经变为new，说明我们已经进入new这个虚拟环境。\n此时再进行python包的安装就是对这个虚拟环境操作，比如我们 pip install numpy（或者 conda install numpy）,再输入\n1conda list # 显示当前虚拟环境的所有包环境 此时我们看到new这个虚拟环境里面已经有numpy这个包了。\n（2）pytorch的安装\n打开pytorch官网：https://pytorch.org/get-started/locally/（pytorch当前建议版本）或者 https://pytorch.org/get-started/previous-versions/ （pytorch的老版本）找到自己所对应版本的使用conda命令安装即可（会慢一些，但建议新手这样做）。\n（3）等待安装完成。 查看pytorch环境是否安装成功：\n要记得先进入之前创建的环境中，然后依次输入蓝色方格中的代码，没有报错，则说明pytorch环境安装完成。\n参考资料： 深度学习 | NVIDIA 开发者 浅析三种Anaconda虚拟环境创建方式和第三方包的安装-腾讯云开发者社区-腾讯云 (tencent.com) 《PyTorch深度学习实践》完结合集_哔哩哔哩_bilibili PyTorch\n","date":1707985156,"headings":[{"anchor":"1anaconda安装","title":"1.Anaconda安装"},{"anchor":"1先检查自己的电脑所支持的cuda版本是多少","title":"(1)先检查自己的电脑所支持的CUDA版本是多少。"},{"anchor":"2cuda与cudnn安装","title":"2.CUDA与CuDNN安装"},{"anchor":"2官网下载相对应的cuda","title":"(2)官网下载相对应的CUDA"},{"anchor":"3gpu版pytorch安装","title":"3.gpu版Pytorch安装"},{"anchor":"3安装相对应版本的cudnn","title":"(3)安装相对应版本的cuDNN。"},{"anchor":"4cpu版pytorch安装","title":"4.cpu版PyTorch安装"}],"kind":"page","lang":"zh-hans","series":["环境配置"],"summary":"","tags":["pytorch"],"title":"Pytorch安装教程","url":"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/python/pytorch%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","year":"2024"},{"content":"在使用github等网站时，我们有时会遇到访问不稳定或无法访问的问题。这时，很多人会选择使用代理来解决问题。但挂上代理之后，我们仍然可能会遇到一个新问题：在命令行中进行下载或配置时，网络问题依然存在。比如，使用pip进行软件包的下载和安装（pip install -r requirements.txt），或者使用git进行代码的下载(git clone ,git push)，都可能因为网络问题而受阻。在我确认已经打开了全局代理的情况下，仍然出现了网络问题，这说明使用命令行进行的操作并没有走代理。\n有三种常用方式：\n①永久设置： linux系统下：\n1vim /etc/profile： 2 export http_proxy=\u0026#39;http://代理服务器IP:端口号\u0026#39; 3 export https_proxy=\u0026#39;http://代理服务器IP:端口号\u0026#39; 4source /etc/profile windows系统下：\n在C:\\User\\用户目录下，新建pip文件夹，然后在该文件夹下新建pip.ini文件。填写如下内容：\n1[global] 2index-url = https://pypi.tuna.tsinghua.edu.cn/simple 3proxy = http://XXXX.com:port 4[install] 5trusted-host=pypi.tuna.tsinghua.edu.cn ②临时设置（重连后失效）： 可以直接在此次命令行窗口运行:\n1export http_proxy=\u0026#39;http://代理服务器IP:端口号\u0026#39; 2export https_proxy=\u0026#39;http://代理服务器IP:端口号\u0026#39; 注意：设置之后可能使用ping时还是无法连接外网，但是pip时可以的，因为ping的协议不一样不能使用这个代理\n③单次设置： 直接在pip时设置代理也是可以的：\n1pip install -r requirements.txt --proxy=代理服务器IP:端口号 ","date":1707984496,"headings":[{"anchor":"临时设置重连后失效","title":"②临时设置（重连后失效）："},{"anchor":"单次设置","title":"③单次设置："},{"anchor":"永久设置","title":"①永久设置："}],"kind":"page","lang":"zh-hans","series":["环境配置"],"summary":"","tags":["python"],"title":"Pip设置代理","url":"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/python/pip%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/","year":"2024"},{"content":"一、操作系统的基本概念 1. 操作系统的特征 (1)并发 并发：同一时间间隔内发生 并行：同一时刻发生 并发，并行的区别辨析非常重要 (2)共享(资源共享方式) 互斥共享 一段时间内只允许一个进程访问该资源（打印机、磁带机） 临界资源（独占资源）：一段时间内只允许一个进程访问的资源 同时访问 一段时间内允许多个进程访问该资源（磁盘、可重入代码） (3)虚拟 空分复用技术是指在物理内存（主存）不够用时，通过将部分数据暂时存储到磁盘上的虚拟内存中，从而在逻辑上扩展了存储器的容量。这样，多个程序可以共享物理内存，每个程序都认为自己拥有连续的、足够的内存空间，而实际上它们的地址空间是交叉存储的，这种技术使得多个程序可以同时运行，而不会相互干扰。 时分复用技术是指将时间分片，轮流分给各个用户或者进程使用，通常用于处理器的分配，如多道程序设计中的时间共享，允许操作系统在很短的时间内切换多个任务，使得每个任务都感觉自己在连续不断地使用处理器。\n总结来说，虚拟存储器使用的是空分复用技术，而虚拟处理机使用的是时分复用技术。\n复用技术 示例 时分复用技术 虚拟处理机（多道程序并发执行分时使用一个处理器）、虚拟设备（spooling技术将一台物理设备虚拟为多台逻辑设备，从而将独占设备变为共享设备） 空分复用技术 虚拟存储器（从逻辑上扩展了存储器的容量） 实际上虚拟存储器既用了时分复用技术，又用了空分复用技术。 空分复用技术体现在虚拟存储器允许将物理内存（RAM）和磁盘存储（通常是硬盘）结合起来使用，形成一个连续的、统一的地址空间。这样，程序的地址空间可以远远大于实际的物理内存大小，因为不常用的数据可以暂时存储在磁盘上，只在需要时才加载到内存中。这种技术使得多个程序可以共享有限的物理内存资源，提高了内存的使用效率。 时分复用技术体现在虚拟存储器的管理上。由于物理内存的大小是有限的，操作系统需要不断地在内存中的程序和数据之间进行切换，以保持所有活动程序的进展。这种切换类似于时分复用技术中的时间片轮转，只不过它是基于内存页面的换入和换出，而不是基于CPU时间片的切换。操作系统会根据程序的访问模式和内存需求，动态地将内存页面在物理内存和磁盘之间移动，这要求操作系统具有高效的数据换入换出算法，如LRU（最近最少使用）算法等。 因此，虚拟存储器同时利用了空分复用技术来扩展地址空间，以及时分复用技术来有效管理有限的物理内存资源。这两种技术的结合，使得虚拟存储器能够提供大容量的地址空间，并且高效地使用有限的物理内存 (4)异步 进程走走停停，以人们不可预知的速度推进 2. 操作系统的目标和功能 （1）计算机系统资源的管理者\n处理机管理、存储器管理、文件管理、设备管理（后面章节细讲） （2）用户与计算机硬件系统的接口\n接口类型 接口子类型 描述 适用场景 用户接口 联机用户接口 一次一句 分时系统、实时系统 用户接口 脱机用户接口 一次一批 批处理系统 用户接口 图形用户接口 使用图形元素（如按钮、窗口）进行交互 个人电脑、图形界面操作系统 程序接口 是用户程序取得操作系统服务的唯一途径，由一组系统调用（广义指令）组成 所有需要操作系统服务的用户程序 （3）对计算机资源的扩充\n没有任何软件的计算机称为裸机；覆盖了软件的计算机称为扩充机器或虚拟机 二、操作系统发展历程 1. 手工操作阶段 程序的装入、运行、结果的输出等所有工作都需要人工干预，资源利用率低，CPU利用不充分 2. 批处理系统 ———\u0026lt;br\u0026gt; 单道批处理系统 多道批处理系统 前提 - 中断技术和通道技术，让CPU和外设能并行工作（2016） 特点 1.自动性：磁带上的一批作业能自动逐个运行\n2.顺序性：磁带上的作业顺序进入内存执行完成\n3.单道性：内存中仅有一道程序运行 1.多道性：内存中有多道程序交替运行`\n2.宏观上并行，微观上串行 优点 相比手工操作系统提高了资源利用率 资源利用率高、CPU利用充分、系统吞吐量大（2017） 缺点 资源利用率还是低 用户响应时间长，不提供人机交互能力（相比于分时系统而言） 3. 分时操作系统 定义：把处理器的运行时间分片，按时间片轮流把处理器分配给各个作业使用 特点：人机交互，多用户共享主机，响应速度快 4. 实时操作系统 目标：及时性、可靠性 特点：资源利用率较低、一般使用高优先级抢占式调度算法 分类 硬实时系统（工业、武器、飞行器控制） 软实时任务（飞机订票系统、银行管理系统、信息查询系统） 5. 网络操作系统、分布式计算机系统、个人操作系统 略微了解 三、操作系统运行环境 1. 处理器运行模式 (1)指令类别\n指令类别 描述 示例 特权指令 不允许用户直接使用的指令 I/O指令、置中断、设置系统时间、存取用于内存保护的寄存器、清理内存、修改权限、进程切换 非特权指令 在用户态可以运行的指令 读写内存、算术运算、命令解释程序 寄存器清零无法判断是特权指令还是非特权指令 (2)CPU运行模式\nCPU运行模式 运行的程序和指令类别 用户态（目态） 用户自编程序和非特权指令运行在用户态 内核态（管态、核心态） 操作系统内核程序和特权指令运行在内核态 (3)转换\n内核态\u0026ndash;\u0026gt;用户态 执行一条特权指令——修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权 用户态\u0026ndash;\u0026gt;内核态 由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权 (4)时钟管理\n向用户提供标准的系统时间 分时系统中时间片轮转调度 实时系统中按截止时间控制运行 批处理系统中衡量一个作业的运行程度 (5)中断机制\n子程序调用只保存PC;中断程序需要保存PC和PSW（2012） 由硬件找到中断向量表，但中断向量表的初始化由操作系统完成（2020） (6)原语操作\n由若干指令组成的、用于完成一定功能的一个过程 执行过程中不允许被中断（可以通过关中断方法实现） 原子操作在系统态下执行，常驻内存 2. 中断和异常的概念 (1)内部异常\n分类方式 类别 描述 示例 发生原因 硬故障中断 硬件线路出现异常 电源掉电、存储器线路错误 发生原因 程序性异常 CPU执行某个指令引起 溢出、地址越界、整数除零、非法指令、时间片中断、单步跟踪 报告和返回方式 故障 操作系统检测到的错误 非法操作码、缺段缺页、整数除零、保护错 报告和返回方式 陷入 程序执行到特定点时故意引发的中断 程序调试断点、系统调用（用户程序的I/O请求）、条件自陷指令 报告和返回方式 终止 需要操作系统进行干预来停止程序的执行的中断 电源掉电、线路故障 (2)中断（外中断）\n示例：I/O设备中断、定时器到时、时钟中断、打印机缺纸、磁盘缓冲满\n阶段 操作 详情 硬件完成 关中断 防止其他中断打断当前中断的处理过程 保存断点（PC和PSW） 记录下被中断的程序计数器和程序状态字 识别中断源 确定是哪个设备或事件触发了中断 操作系统完成 保护现场（寄存器信息） 保存当前执行的程序的寄存器值，以便中断服务完成后能够恢复 屏蔽字 根据需要设置屏蔽字，控制哪些中断可以被响应，哪些需要被忽略 执行中断服务程序 调用相应的中断处理程序来响应和处理中断请求 中断和异常的概念辨析非常重要！！！异常和中断是操作系统处理意外或特定事件时使用的两种机制，它们有一些关键的区别： 来源不同： 中断（Interrupt）通常是由外部设备发出的信号，通知CPU有一个需要立即处理的紧急事件。例如，当用户输入数据时，键盘会产生一个中断信号。 异常（Exception）是由CPU在执行内部指令时产生的，通常是因为内部错误或程序执行了某些特殊的指令（如系统调用）。异常是同步发生的，即在指令执行期间或之后立即被识别和处理的。 处理方式不同： 中断通常是异步的，它们的处理程序需要能够处理随机发生的中断，并且在处理中断时可能需要保存当前处理的上下文（如程序计数器和其他寄存器的值），以便之后能够恢复被中断的任务。 异常是同步的，它们在特定的指令执行时被触发，操作系统在处理异常时通常不需要保存和恢复上下文，因为异常是在控制流顺序中的。 类型划分不同： 中断可以分为可屏蔽中断和非可屏蔽中断。可屏蔽中断可以被CPU忽略，而非可屏蔽中断则必须立即处理。 异常可以分为多种类型，如硬件故障导致的故障、程序执行了非法操作码导致的陷阱、程序请求操作系统服务时的系统调用等。 目的不同： 中断的目的是为了响应外部事件，如I/O请求、时钟信号等。 异常的目的是为了处理程序执行中的错误或特殊请求。 总的来说，中断和异常都是操作系统用来处理不同类型事件的重要机制，它们在处理时机、来源和处理方式上有所不同。操作系统需要通过合理地处理这些事件来保证系统的稳定性和响应性。 总结为如下表格：\n特征 中断 异常 来源 外部设备信号 CPU执行指令时产生的内部事件 发生方式 异步 同步 处理方式 需保存和恢复上下文 通常不需要保存和恢复上下文 类型 可屏蔽/非可屏蔽 故障、陷阱、系统调用等 目的 响应外部事件（如I/O请求、时钟信号） 处理程序执行中的错误或特殊请求 3. 系统调用(广义指令) 系统调用过程 （传递调用参数、执行陷入指令、执行服务程序、返回用户态） 特点 系统调用是操作系统提供给应用程序的接口（2010、2019） 每个系统有许多系统调用，每个系统调用有唯一的系统调用号 一个操作系统所有的系统调用都通过一个中断入口来实现，不同操作系统为用户提供的系统调用接口不同（2019） 在执行系统调用服务程序的过程中，CPU处于内核态（2019） 系统调用只能通过用户程序间接使用 访管指令 名称：访管指令、陷入指令、trap指令 在用户态使用，不是特权指令，用户程序借此发起系统调用 广义指令的调用可能在用户态，但执行一定在内核态 四、操作系统结构 五、操作系统引导 步骤描述：\n①激活CPU。激活的CPU读取 ROM中的 boot（自举）程序，开始执行BIOS的指令 ②硬件自检。启动BIOS程序后，先进行硬件自检，检查硬件是否出现故障 ③加载带有操作系统的硬盘。BIOS读取Boot Sequence，然后CPU将存储设备引导扇区的内容加载到内存中 ④加载主引导记录 MBR。轮流查找引导硬盘（主引导记录MBR的作用是告诉CPU去硬盘的哪个主分区去找操作系统） ⑤扫描硬盘分区表并加载硬盘活动分区。主引导记录扫描硬盘分区表，识别并加载含有操作系统的硬盘分区（活动分区) ⑥加载分区引导记录PBR。读取分区引导记录(PBR)，其作用是寻找并激活分区根目录下用于引导操作系统的启动管理器 ⑦加载启动管理器。分区引导记录搜索活动分区中的启动管理器，加载启动管理器 ⑧加载操作系统到内存RAM（2013） 引导程序分为两种，分别是位于ROM中的自举程序和位于引导扇区的启动管理器。 操作系统引导只是将操作系统内核加载到内存，其它部分仅在需要时才调入。 六、虚拟机 虚拟内核态：虚拟机上的操作系统认为自己运行在内核态（并不是）\n用户态：虚拟机中的用户进程认为自己运行在用户态（确实是）\n描述\n虚拟机可以用软件实现也可以用硬件实现 虚拟机是运行在计算机中的一个应用程序 真实硬件不会执行虚拟机中的敏感指令 ","date":1707845958,"headings":[{"anchor":"1-处理器运行模式","title":"1. 处理器运行模式"},{"anchor":"1-手工操作阶段","title":"1. 手工操作阶段"},{"anchor":"1-操作系统的特征","title":"1. 操作系统的特征"},{"anchor":"1并发","title":"(1)并发"},{"anchor":"2-中断和异常的概念","title":"2. 中断和异常的概念"},{"anchor":"2-批处理系统","title":"2. 批处理系统"},{"anchor":"2-操作系统的目标和功能","title":"2. 操作系统的目标和功能"},{"anchor":"2共享资源共享方式","title":"(2)共享(资源共享方式)"},{"anchor":"3-分时操作系统","title":"3. 分时操作系统"},{"anchor":"3-系统调用广义指令","title":"3. 系统调用(广义指令)"},{"anchor":"3虚拟","title":"(3)虚拟"},{"anchor":"4-实时操作系统","title":"4. 实时操作系统"},{"anchor":"4异步","title":"(4)异步"},{"anchor":"5-网络操作系统分布式计算机系统个人操作系统","title":"5. 网络操作系统、分布式计算机系统、个人操作系统"},{"anchor":"一操作系统的基本概念","title":"一、操作系统的基本概念"},{"anchor":"三操作系统运行环境","title":"三、操作系统运行环境"},{"anchor":"二操作系统发展历程","title":"二、操作系统发展历程"},{"anchor":"五操作系统引导","title":"五、操作系统引导"},{"anchor":"六虚拟机","title":"六、虚拟机"},{"anchor":"四操作系统结构","title":"四、操作系统结构"}],"kind":"page","lang":"zh-hans","summary":"","tags":["操作系统"],"title":"第一章：操作系统引论","url":"/408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/","year":"2024"},{"content":"anaconda下载地址（官网）：\nFree Download | Anaconda\n一、创建Anaconda虚拟环境 步骤1：打开Anaconda Prompt (终端) 首先，在Windows系统中，通过开始菜单或搜索找到“Anaconda Prompt”，在Mac或Linux系统中，可以在终端中直接操作。\n步骤2：创建虚拟环境 在命令行界面输入以下命令来创建一个新的虚拟环境。这里以创建一个名为 my_project_env，并指定Python版本为3.9.10（请根据实际情况替换）的环境为例：\n1conda create --name my_project_env python=3.9.10 注意：此处——name和—n等效\n解决创建环境时出现的： Collecting package \u0026hellip; failed\n创建环境时，可能会出现以下问题\n问题分析：因为网络问题导致的创建失败\n解决方法：多试几次，仍然失败更换国内镜像源\n找到C盘用户文件夹下的.condarc文件 \\2. 编辑.condarc文件，替换成以下内容，保存，重新打开cmd即可\n1ssl_verify: true 2channels: 3 - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/win-64/ 4 - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/win-64 show_channel_urls: true 此方法直接更换成了清华源，速度更快，更稳，通过conda向虚拟环境安装第三方包时，用的也是清华源。\n步骤3：激活虚拟环境 虚拟环境创建完成后，需要激活它以便在该环境中执行后续操作。激活环境的命令如下：\n1conda activate my_project_env 当你成功激活虚拟环境后，命令行提示符前通常会显示当前活动环境的名称，例如 (my_project_env)。\n查看所有虚拟环境的命令：\n1conda env list 二、在虚拟环境中安装第三方包 方法1：使用Conda安装 对于那些在Conda仓库中存在的包，你可以直接用 conda install 命令进行安装。例如，要安装numpy库：\n1conda install numpy 方法2：使用pip安装 对于Conda仓库中没有或者你想从PyPI获取的包，可以使用 pip 在虚拟环境中安装：\n1pip install pandas pip安装速度过慢时，可以将pip更换为国内镜像源：\n安装特定版本的包 如果需要安装特定版本的第三方包，只需在包名后面加上版本号即可：\n1conda install scipy=1.7.3 # 使用conda安装Scipy的1.7.3版本 2pip install tensorflow==2.8.0 # 使用pip安装TensorFlow的2.8.0版本 三、检查已安装的包 安装完成后，可以通过下面的命令查看虚拟环境中已经安装的所有包及其版本信息：\n1conda list 或者使用pip列出所有已安装的pip包：\n1pip list 四、关闭/退出虚拟环境 当完成工作并希望回到系统默认Python环境时，执行以下命令：\n1conda deactivate 至此，您已成功地使用Anaconda创建了一个虚拟环境，并在其中安装了所需的第三方包。这种做法有助于保持项目之间的依赖独立，使得代码更易于管理和部署。\n五、删除虚拟环境 当某个项目完成或者不再需要某个虚拟环境时，可以使用以下命令将其彻底删除：\n1conda remove --name my_project_env --all 这里的 my_project_env 是你想要删除的虚拟环境名称。执行上述命令后，Anaconda将会从系统中移除该虚拟环境及其所有安装的包和配置文件。\n注意事项：\n删除操作不可逆，请在执行此命令前确保您确实不再需要该虚拟环境中的任何内容。 确认环境名称无误，避免误删其他正在使用的虚拟环境。 请根据实际需求和最新版Anaconda的更新情况调整上述命令中的具体版本信息。\n","date":1707845958,"headings":[{"anchor":"一创建anaconda虚拟环境","title":"一、创建Anaconda虚拟环境"},{"anchor":"三检查已安装的包","title":"三、检查已安装的包"},{"anchor":"二在虚拟环境中安装第三方包","title":"二、在虚拟环境中安装第三方包"},{"anchor":"五删除虚拟环境","title":"五、删除虚拟环境"},{"anchor":"四关闭退出虚拟环境","title":"四、关闭/退出虚拟环境"},{"anchor":"安装特定版本的包","title":"安装特定版本的包"},{"anchor":"方法1使用conda安装","title":"方法1：使用Conda安装"},{"anchor":"方法2使用pip安装","title":"方法2：使用pip安装"},{"anchor":"步骤1打开anaconda-prompt-终端","title":"步骤1：打开Anaconda Prompt (终端)"},{"anchor":"步骤2创建虚拟环境","title":"步骤2：创建虚拟环境"},{"anchor":"步骤3激活虚拟环境","title":"步骤3：激活虚拟环境"}],"kind":"page","lang":"zh-hans","series":["环境配置"],"summary":"","tags":["python"],"title":"使用Anaconda管理python虚拟环境与安装第三方包","url":"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/python/%E4%BD%BF%E7%94%A8anaconda%E8%BD%BB%E6%9D%BE%E7%AE%A1%E7%90%86python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85/","year":"2024"},{"content":"1.临时换源： 清华源\n1pip install xxxx -i https://pypi.tuna.tsinghua.edu.cn/simple 阿里源\n1pip install xxxx -i https://mirrors.aliyun.com/pypi/simple/ 腾讯源\n1pip install xxxx -i http://mirrors.cloud.tencent.com/pypi/simple 豆瓣源\n1pip install xxxx -i http://pypi.douban.com/simple/ 将xxxx换成需要安装的包的名字\n2.永久换源： 清华源\n1pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 阿里源\n1pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/ 腾讯源\n1pip config set global.index-url http://mirrors.cloud.tencent.com/pypi/simple 豆瓣源\n1pip config set global.index-url http://pypi.douban.com/simple/ 3.换回默认源 1pip config unset global.index-url ","date":1707844801,"headings":[{"anchor":"1临时换源","title":"1.临时换源："},{"anchor":"2永久换源","title":"2.永久换源："},{"anchor":"3换回默认源","title":"3.换回默认源"}],"kind":"page","lang":"zh-hans","series":["环境配置"],"summary":"","tags":["python"],"title":"pip修改国内镜像源（临时/永久）","url":"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/python/pip%E6%8D%A2%E6%BA%90/","year":"2024"}]